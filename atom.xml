<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://joserccblog.github.io</id>
    <title>君赏博客</title>
    <updated>2019-09-06T06:58:20.687Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://joserccblog.github.io"/>
    <link rel="self" href="https://joserccblog.github.io/atom.xml"/>
    <subtitle>2012年从事iOS开发，资深iOS开发菜鸟，目前在环球易购占坑。喜欢研究偏门技术，喜欢自动化编程，喜欢研究小软件提高编程效率</subtitle>
    <logo>https://joserccblog.github.io/images/avatar.png</logo>
    <icon>https://joserccblog.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 君赏博客</rights>
    <entry>
        <title type="html"><![CDATA[Objective-C 如何实现递进式链式语法]]></title>
        <id>https://joserccblog.github.io/post/objective-c-ru-he-shi-xian-di-jin-shi-lian-shi-yu-fa</id>
        <link href="https://joserccblog.github.io/post/objective-c-ru-he-shi-xian-di-jin-shi-lian-shi-yu-fa">
        </link>
        <updated>2019-09-06T03:10:03.000Z</updated>
        <content type="html"><![CDATA[<p>关于链式语法其实很简单，就是写返回值是 Block 类型的方法即可。</p>
<p>最近要做仿 SwiftUI 的衍生品 OCUI,也是属于自己瞎折腾。但是对于要做成 SwiftUI 的链式语法有些困难。</p>
<p>比如我们之前写链式语法这样写的</p>
<pre><code class="language-objc">@interface ClassA : NSObject

- (ClassA *(^)(CGFloat))top;
- (ClassA *(^)(CGFloat))bottom;

@end
</code></pre>
<p>但是如果存在基类，比如下面。</p>
<pre><code class="language-objc">@interface ClassB: ClassA

- (ClassB *(^)(CGFloat))leading;
- (ClassB *(^)(CGFloat))trailing;

@end
</code></pre>
<p>这样就存在一个问题调用了父类的链式方法再也调用不了子类的链式方法。</p>
<p>如果想要解决这个问题很简单，把上面的链式代码改成下面即可。</p>
<pre><code class="language-objc">@interface ClassA : NSObject

- (instancetype(^)(CGFloat))top;
- (instancetype(^)(CGFloat))bottom;

@end
  
@interface ClassB: ClassA

- (instancetype(^)(CGFloat))leading;
- (instancetype(^)(CGFloat))trailing;

@end
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Objective-C版本的SwiftUI库的自动生成布局的研究心得]]></title>
        <id>https://joserccblog.github.io/post/guan-yu-objective-c-ban-ben-de-swiftui-ku-de-zi-dong-sheng-cheng-bu-ju-de-yan-jiu-xin-de</id>
        <link href="https://joserccblog.github.io/post/guan-yu-objective-c-ban-ben-de-swiftui-ku-de-zi-dong-sheng-cheng-bu-ju-de-yan-jiu-xin-de">
        </link>
        <updated>2019-08-29T04:20:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>最新突然突发奇想先做 <code>Objective-C</code>版本的<code>SwiftUI</code>这个仿生库 <a href="https://github.com/swiftkitui/OCUI">OCUI</a>。发现其实困难还是很多的，比如基于<code>Swift</code>语法的语法特性可以让语法特别简洁，但是<code>OC</code>就显的十分的臃肿了。</p>
<ul>
<li>
<p>一个简单的横向文本居中</p>
<pre><code class="language-objc">HStack(^{
    Text(@&quot;Hello World!&quot;);
});
</code></pre>
</li>
</ul>
<p>虽然居中大家都知道，可以用<code>Masonry</code>直接设置<code>Center</code>居中即可，但是却不适合其他的场景。</p>
<p>对于<code>SwiftUI</code>布局通常有下面四个</p>
<ul>
<li>
<p><code>VStack</code></p>
<p>纵向布局</p>
</li>
<li>
<p><code>HStack</code></p>
<p>横向布局</p>
</li>
<li>
<p><code>ZStack</code></p>
<p>垂直布局</p>
</li>
<li>
<p><code>Spacer</code></p>
<p>空隙填充</p>
</li>
</ul>
<p>目前我做的是横向布局<code>HStack</code>和<code>Spacer</code>。</p>
<h2 id="布局框架示意图">布局框架示意图</h2>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-013334.png" alt="image-20190829093331823"></p>
<p>布局基本上是按照上面图所示进行填充的。<code>Spacer</code>只在框架存在，在页面上已经变成布局的约束了。</p>
<p>这个布局思路，不知道从什么地方开始将，不如从 例子从简单到复杂的开始说起吧。</p>
<h3 id="单个文本居中显示">单个文本居中显示</h3>
<pre><code class="language-objc">HStack(^{
    Text(@&quot;Hello World!&quot;);
});
</code></pre>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-013913.png" alt="image-20190829093912352"></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-014103.png" alt="image-20190829094101704"></p>
<p>其实看我们的代码里面是没有出现任何的<code>Spacer</code>布局的，我们可以在内部布局的时候如果缺失左右填充时候，可以进行添加。</p>
<p>我们此时生成布局方案的时候不能按照直接设置下面的伪代码</p>
<pre><code class="language-objc">[label mas_makeConstraints:^(MASConstraintMaker *make) {
	make.center(superView);
}];
</code></pre>
<p>我们正常的会按照这样布局的，但是作为一个框架，不可能写无数个布局方案处理，应该有一个通用的布局方案。</p>
<p>既然左侧和右侧的<code>Spacer</code>的长度是按照中间显示文本的宽度自动计算的，那么我们可以在布局之前优先的算出<code>Spacer</code>的具体宽度。</p>
<pre><code class="language-objc">CGFloat spacerWidth = (HStackWidth - LabelWidth) / 2;
</code></pre>
<p>我们先拿到父试图的宽度，目前按照会自动充满屏幕，就是屏幕的宽度<code>ScreenWidth</code>。因为<code>UILabel</code>是可以自动计算出合适大小的。我们可以使用<code>UIView</code>的<code>intrinsicContentSize</code>属性得到适合的宽度。</p>
<p>关于生成布局的思路可以把布局拆解出来</p>
<ul>
<li>布局上下的位置</li>
<li>布局大小</li>
<li>布局左侧或者右侧的位置</li>
</ul>
<h4 id="布局上下位置">布局上下位置</h4>
<p>对于<code>HStack</code>支持三种布局分别是下面</p>
<ul>
<li>
<p><code>Top</code></p>
</li>
<li>
<p><code>Center</code></p>
<p>默认布局类型</p>
</li>
<li>
<p><code>Bottom</code></p>
</li>
</ul>
<p>我们可以根据设置的三种类型进行上下布局</p>
<pre><code class="language-objc">if (top) {
	make.top.equal(superView);
} else if (center) {
	make.centerY.equal(superView);
} else {
	make.bottom.equal(superView);
}
</code></pre>
<h4 id="关于大小布局">关于大小布局</h4>
<p>我们对于<code>intrinsicContentSize</code>可以计算出大小的不进行布局，让系统自动约束。对于计算不出来的大小的<code>UIView</code>可以单独调用<code>renderSize</code>协议方法获取试图的大小。</p>
<p>如果<code>renderView</code>的宽度为<code>0</code>，就引出了自动约束试图大小的布局，这个下面讲述。宽度不为<code>0</code>,我们可以设置下面约束</p>
<pre><code class="language-objc">make.width.mas_equalTo(width);
</code></pre>
<p>如果<code>renderView</code>的高度不存在，我们就设置为父试图的全部高度。</p>
<pre><code class="language-objc">if (renderViewHeight &gt; 0) {
	make.height.mas_equalTo(renderViewHeight);
} else {
  make.height.equal(superView);
}
</code></pre>
<h4 id="关于左侧和右侧布局">关于左侧和右侧布局。</h4>
<p>我的思路是这样的</p>
<ul>
<li>如果和左侧的试图间距已知就按照左侧的进行布局</li>
<li>如果和左侧的试图间距可变就按照右侧已知间距的进行布局</li>
<li>如果和左侧的试图间距可变就按照右侧 如果右侧间距未知就按照右侧约束走</li>
</ul>
<pre><code class="language-objc">/// 是否存在左侧固定间距
if (leftSpacerFlxedOffset) {
	if (isSuperView) {
		make.leading.equeal(superView).offset(leftSpacerFlxedOffset.value)
	} else {
		make.leading.equeal(superView.mas_trailing).offset(leftSpacerFlxedOffset.value)
	}
} else if (rightSpacerFlxedOffset) {
	/// 是否存在右侧的固定间距
	if (isSuperView) {
		make.trailing.equeal(superView).offset(-leftSpacerFlxedOffset.value)
	} else {
		make.trailing.equeal(superView.mas_leading).offset(-leftSpacerFlxedOffset.value)
	}
} else {
	if (isSuperView) {
		make.trailing.lessThanOrEqualTo(superView).offset(-leftSpacerFlxedOffset.value)
	} else {
		make.trailing.lessThanOrEqualTo(superView.mas_leading).offset(-leftSpacerFlxedOffset.value)
	}
}
</code></pre>
<h3 id="两个文本横向居中对齐">两个文本横向居中对齐</h3>
<pre><code class="language-objc">HStack(^{
    Text(@&quot;Hello World!&quot;);
    Text(@&quot;Hello 张行!&quot;);
});
</code></pre>
<p><img src="images/image-20190829112454402.png" alt="image-20190829112454402"></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-032612.png" alt="image-20190829112611122"></p>
<p>此时我们的代码仅仅是比上一个例子多了下面代码</p>
<pre><code class="language-objc">Text(@&quot;Hello 张行!&quot;);
</code></pre>
<p>按照上面的布局思路，我们可以想象一下中间存在一个固定间隙为<code>0</code>的<code>Spacer</code>。按照这个思路，我们可以给<code>Spacer</code>新增一个固定间隙的属性。从而可以实现下面的效果。</p>
<h3 id="两个文本间隙10并且居中显示">两个文本间隙10并且居中显示</h3>
<pre><code class="language-objc">HStack(^{
    Text(@&quot;Hello World!&quot;);
    Spacer(@10);
    Text(@&quot;Hello 张行!&quot;);
});
</code></pre>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-033257.png" alt="image-20190829113255984"></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-033321.png" alt="image-20190829113319194"></p>
<h3 id="两个文本左右对齐">两个文本左右对齐</h3>
<pre><code class="language-objc">HStack(^{
    Text(@&quot;Hello World!&quot;);
    Spacer(nil);
    Text(@&quot;Hello 张行!&quot;);
});
</code></pre>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-033439.png" alt="image-20190829113437202"></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-033554.png" alt="image-20190829113553088"></p>
<p>我们可以设置最左侧和做右侧的<code>Spacer</code>的固定间隙为0。</p>
<h3 id="一个复杂一点的设置-cell-布局">一个复杂一点的设置 Cell 布局</h3>
<pre><code class="language-objc">HStack(^{
    Spacer(@15);
    Image(nil)
        .size(CGSizeMake(25, 25))
        .backgroundColor([UIColor redColor]);
    Spacer(@10);
    Text(@&quot;WIFI&quot;);
    Spacer(nil);
    Text(@&quot;未连接&quot;);
    Spacer(@15);
});
</code></pre>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-033850.png" alt="image-20190829113847342"></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-034341.png" alt="image-20190829114334862"></p>
<p>可能此时也已经发现了问题，当我设置左侧文本的时候，应该中间的<code>Spacer</code>的间隙需要自动变小。但是其实事实上并没有。</p>
<p>因为开始的时候我们计算出了浮动间隙的具体值，我们设置了最小值。</p>
<p>目前的方案是做了<code>KVO</code>的监听文本<code>Text</code>的变化，从而重新计算间隙的大小，更新约束。</p>
<p>对于重新计算间隙的大小，还有一个复杂的逻辑。</p>
<h3 id="四个文本左右间距为0-怎么让中间的间隙一直保持不变">四个文本左右间距为0 怎么让中间的间隙一直保持不变。</h3>
<pre><code class="language-objc">HStack(^{
    Text(@&quot;文本1&quot;);
    Spacer(nil);
    Text(@&quot;文本2&quot;);
    Spacer(nil);
    Text(@&quot;文本3&quot;);
    Spacer(nil);
    Text(@&quot;文本4&quot;);
});
</code></pre>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-034912.png" alt="image-20190829114911218"></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-035047.png" alt="image-20190829115046184"></p>
<p>我们还存在一种情况，就是可能两个文本之间有最小间隙。</p>
<p>假设三个<code>Spacer</code>的最小间隙分别是<code>10</code> <code>20</code> <code>30</code>。</p>
<p>我们获取可以浮动的宽度就等于</p>
<pre><code class="language-objc">CGFloat floatWidth = width - text1Width - text2Width - text3Width - text4Width;
</code></pre>
<p>我们可以算出间隙最小承受的值</p>
<pre><code class="language-objc">CGFloat minFloatWidth = 10 + 20 + 30;
</code></pre>
<p>我们可以算出间隙最大的值</p>
<pre><code class="language-objc">CGFloat maxFloatWidth = 30 * 3; /// MAX(10,20,30..) * count;
</code></pre>
<p>这个最大的值其实就是大于或者等于就可以把浮动的间隙平分。</p>
<pre><code class="language-objc">if (floatWidth &lt;= minFloatWidth) {
	// 按照最小的间隙更新布局
} else if (floatWidth &gt; minFloatWidth &amp;&amp; minFloatWidth &lt; maxFloatWidth) {
	// 就按照优先级最低的按照最小间距布局 默认为最后一个优先级最小
} else {
	// 平分计算进行更新布局
}
</code></pre>
<h3 id="一个全部充满的红色试图">一个全部充满的红色试图</h3>
<pre><code class="language-objc">HStack(^{
    View()
    .backgroundColor([UIColor redColor]);
});
</code></pre>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-040238.png" alt="image-20190829120236761"></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-040326.png" alt="image-20190829120324371"></p>
<p>这个布局其实和刚才<code>Spacer</code>的思路是一样的，但是存在不确定大小的试图，就不允许存在不确定间隙的<code>Spacer</code>存在。</p>
<h3 id="三个试图平分">三个试图平分</h3>
<pre><code class="language-objc">HStack(^{
    View()
        .backgroundColor([UIColor redColor]);
    View()
        .backgroundColor([UIColor blueColor]);
    View()
        .backgroundColor([UIColor grayColor]);
});
</code></pre>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-041301.png" alt="image-20190829121259682"></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-041338.png" alt="image-20190829121336235"></p>
<h3 id="三个试图其中一个设置具体大小">三个试图其中一个设置具体大小</h3>
<pre><code class="language-objc">HStack(^{
    View()
        .backgroundColor([UIColor redColor]);
    View()
        .backgroundColor([UIColor blueColor])
        .size(CGSizeMake(40, 40));
    View()
        .backgroundColor([UIColor grayColor]);
});
</code></pre>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-041527.png" alt="image-20190829121526417"></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-08-29-041607.png" alt="image-20190829121606143"></p>
<blockquote>
<p>OCUI 正在测试开发阶段，Api 会尽量和<code>SwiftUI</code>保持一致。但是最后的 Api 按照最后发布为准。欢迎有志之士加入这个项目。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 对于 Codable 协议过滤一些属性]]></title>
        <id>https://joserccblog.github.io/post/swift-dui-yu-codable-xie-yi-guo-lu-yi-xie-shu-xing</id>
        <link href="https://joserccblog.github.io/post/swift-dui-yu-codable-xie-yi-guo-lu-yi-xie-shu-xing">
        </link>
        <updated>2019-05-07T01:25:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>我们在 <code>Swift</code> 创建模型的时候，通常要实现系统的 <code>Codable</code>协议来支持模型的 <code>encode</code>和 <code>decode</code>功能。</p>
<p>但是我们通常并不希望所有的属性都进行编码和解码，比如一些用于计算或者转换临时的私有属性。</p>
<pre><code class="language-swift">class TestModel: Codable {
    var name:String?
    private var privateName:String?
}
</code></pre>
<p>比如上面的代码中的 <code>privateName</code>在一些情况下面就需要私有，不需要进行编码。</p>
<h2 id="解决办法">解决办法</h2>
<pre><code class="language-swift">private enum CodingKeys : String, CodingKey {
        case name
    }
</code></pre>
<p>我们实现私有的 <code>CodingKeys</code>属性，把需要进行编码和解码的属性添加进行就行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自己制作 Framework提示Missing submodule xxx]]></title>
        <id>https://joserccblog.github.io/post/2018-04-17-【已解决】自己制作-framework提示missing-submodule-xxx</id>
        <link href="https://joserccblog.github.io/post/2018-04-17-【已解决】自己制作-framework提示missing-submodule-xxx">
        </link>
        <updated>2018-04-16T19:59:42.000Z</updated>
        <content type="html"><![CDATA[<p><strong>【未解决】自己制作 Framework提示Missing submodule xxx</strong></p>
<h2 id="问题描述">问题描述</h2>
<p>最新在做基于 <code>Carthage</code> 把一些第三方托管到 <code>Carthage</code> 生成 <code>Framework</code> 来加快编译速度。</p>
<p>但是在托管自己的一个库 <code>ZHTableViewGroup</code>时候导入遇到了下面的问题提示</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2018-04-17-8F767DD2-D513-4688-AD1B-7417812E6A99.png" alt="8F767DD2-D513-4688-AD1B-7417812E6A99"></p>
<p>虽然可以正常的编译，但是警告还是让我浑身觉得不舒服，特别我还有一点代码洁癖。</p>
<h2 id="解决办法">解决办法</h2>
<p>经过谷歌查询 原因是创建的库名称自动生成的头文件和 <code>Framework</code> 包含的某个类的头文件重名。</p>
<p>可以创建时候比如命名 <code>ZHTableViewGroup iOS</code> 那么自动生成的头文件就是 <code>ZHTableViewGroup_iOS.h</code>。</p>
<p>我们把所有 <code>Framework</code> 的头文件添加到 <code>ZHTableViewGroup_iOS.h</code>，集成时候导入下面的。</p>
<pre><code class="language-Objc">#import &lt;ZHTableViewGroup/ZHTableViewGroup_iOS.h&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[怎么在Framework支持@IBDesignable]]></title>
        <id>https://joserccblog.github.io/post/2017-12-22-怎么在framework支持@ibdesignable</id>
        <link href="https://joserccblog.github.io/post/2017-12-22-怎么在framework支持@ibdesignable">
        </link>
        <updated>2017-12-22T01:45:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="对于-framework-不支持ibdesignable研究">对于 Framework 不支持@ibdesignable研究</h2>
<p>写出这一篇文章之前，我搜索了很多的资料。牵扯出来的东西实在是太多，很多我没法理解其中的原理，可能我看的不详细，并且不需要去知道牵扯出来原理，我只是想解决办法而已。</p>
<p>最近写了一个控件，是为了做<strong>共享车位</strong>项目的一个选择控件。在最后的版本我加了<code>@IBDesignable</code>和<code>@IBInspectable</code>两个关键词用于支持 <code>Xib</code> 的及时预览和设置。</p>
<p>最近在想使用 <code>Carthage</code> 打包成 <code>Framework</code> 之后，放在 <code>Cocoapods</code> 进行依赖，会简单很多。</p>
<p>但是我们的控件在 <code>Xib</code> 不能及时的预览，不能及时的渲染。我们的代码可是在自己的例子里面经过测试的！</p>
<p>我们不但在 <code>Swift</code> 的例子里面测试通过，而且还在 <code>OC</code> 的例子里面测试通过。但是我们托管在 <code>Cocoapods</code> 之后，竟然无法通过了？</p>
<p>当时一时不明白什么原因，恰巧看到群里面有人分享说 <code>Xcode9</code>之前 <code>Swift</code> 不支持静态库。</p>
<blockquote>
<p>https://zhuanlan.zhihu.com/p/32178522?group_id=926848741735350272</p>
</blockquote>
<p>当时就好奇的搜索一下什么是静态库和动态库。</p>
<blockquote>
<p>https://www.jianshu.com/p/42891fb90304</p>
</blockquote>
<p>下面我就说一下我的理解，简单说一下所谓的动态库是可以代码共享供其他程序使用的，比如系统的 <code>UIKit.framework</code> <code>Foundation.framework</code> 都是存在于 <code>iOS</code>系统里面。</p>
<p>不同的 <code>APP</code> 都是依赖于 <code>iOS</code> 系统里面这些动态库，这就所谓我们的安装包会变小。</p>
<p>所谓的静态库就是复制一份代码到我们的 <code>APP</code> 里面，比如其他第三方打包号的 <code>Framework</code>，比如 <code>Cocoapods</code> 托管的。</p>
<p>说到这里，我们已经注意到为什么自己打包出来的<code>.Framework</code> 是赋值代码到我们 <code>APP</code> 是属于静态库，为什么系统的<code>.framework</code> 是属于共享代码属于动态库呢？</p>
<p>我们自己口中所谓的创建动态库和静态库究竟是怎么的一回事呢？我们看一下下面的图。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-23-0E17A928-4701-464E-9DCF-67C76129E07B.png" alt="0E17A928-4701-464E-9DCF-67C76129E07B"></p>
<p>这就是我理解的图，所以对于 <code>Framework</code> 有三种</p>
<ol>
<li>存在于 <code>iOS</code> 系统供其他 <code>APP</code> 共享代码使用的真正动态库</li>
<li>存在于 <code>APP</code> 沙盒下面供扩展程序和主程序使用的伪动态库</li>
<li>复制代码只供主程序使用的静态库</li>
</ol>
<p>搜索了静态库和动态库的区别之后，对比自己测试的 <code>Demo</code> 和自己真正用的例子发现。</p>
<p>自己的 <code>Demo</code> 都在一个工程，属于伪动态的库。但是自己打包成 <code>Framework</code> 不管是拖拽还是使用 <code>Cocoapods</code> 都已经变成了静态库了。所以应该是这个原因导致的。</p>
<p>后来，我就直接让代码使用 <code>Cocoapods</code> 进行托管。但是发现还是不行，当时就百度了</p>
<pre><code class="language-She">Cocoapods not support @IBDesignable
</code></pre>
<p>虽然这个问题在 <code>Cocoapods</code> 的问题列表出现很多次，但是官方给的回复是我们的库有问题和 <code>Cocoapods</code> 没有什么关系。</p>
<p>最后我再次修改了搜索的关键词</p>
<pre><code class="language-shell">swift @IBDesignable framework not work in xib
</code></pre>
<p>这次搜索果然有收获，并且大概知道了解决的办法。</p>
<blockquote>
<p>https://github.com/Carthage/Carthage/issues/335</p>
</blockquote>
<blockquote>
<p>http://stackoverflow.com/a/39999914/760435</p>
</blockquote>
<p>一个采纳的建议为使用者自己创建子类或者分类，重写<code>@IBDesignable</code>标识符。</p>
<p>我试了一些，是可以正常的渲染出来，但是属性还是无法在 <code>Xib</code> 设置。</p>
<p>此时此刻，我大概明白了出不来造成的原因是什么。是因为 <code>Swift</code> 文件会被自动 <code>Generated Interface</code> 头文件的时候</p>
<p><code>@IBDesignable</code>和<code>@IBDesignable</code>关键词不会被自动转换为 <code>OC</code> 的宏<code>IB_DESIGNABLE</code>和<code>IBInspectable</code>。</p>
<p>因为打包成 <code>Framework</code> 会被自动转换为 <code>OC</code> 里面的头文件，因此缺少标识的宏自然无法在 <code>Xib</code> 进行渲染和识别。</p>
<h2 id="三种方法可以解决">三种方法可以解决</h2>
<h3 id="1代码开源使用-cocoapods">1.代码开源使用 Cocoapods</h3>
<p>使用 <code>Cocoapods</code> 直接托管我们的源文件，这样就形成了我们所说的伪动态库。</p>
<p>只有在运行的时候才被编译成库，这样 <code>Xib</code> 就可以在编译的时候看到源文件，识别出<code>@IBDesignable</code>和<code>@IBDesignable</code>关键词。</p>
<h3 id="2-打包成-framework">2. 打包成 Framework</h3>
<p>如果想使用 <code>Framework</code> 的话，比如使用 <code>Carthage</code> 之类。自动生成的头文件自然是无法支持的。</p>
<p>我们想要支持的话就必须是把我们声明<code>@IBDesignable</code>和<code>@IBDesignable</code>关键词的文件暴露在 <code>public header</code> 列表之下。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-23-34C8DA6D-B199-4B42-A5FD-7043D407BD8F.png" alt="34C8DA6D-B199-4B42-A5FD-7043D407BD8F"></p>
<p>那么打包出来的 <code>Framework</code> ，程序也可以看到我们的源文件，自然而然的就支持 Xib 渲染了。</p>
<h3 id="3-打包成-framework-不想让别人知道核心代码">3. 打包成 Framework 不想让别人知道核心代码</h3>
<p>这个就有点难度了，毕竟你不想让别人知道核心代码。又要让自己的库支持<code>Xib</code>的话。</p>
<p>你就必须参考上面2所说的，做一个可以暴露源码的文件，把<code>@IBDesignable</code>和<code>@IBDesignable</code>关键词写在这个文件里面。之后再把设置的属性赋值给核心库，这样核心的类会自动生成。</p>
<p>类似下面</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-23-0095545E-CCE3-47D7-89BF-439A7003A8F3.png" alt="0095545E-CCE3-47D7-89BF-439A7003A8F3"></p>
<p>这样只不过提供库作者麻烦一些，谁让自己不愿意开源呢？</p>
<blockquote>
<p>据说 Framework 不支持@IBDesignable是苹果的一个 BUG，至今还没有修复</p>
<p>https://openradar.appspot.com/23114017</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mas_updateConstraints更新约束引起的约束冲突]]></title>
        <id>https://joserccblog.github.io/post/2018-04-08-mas_updateConstraints更新约束引起的约束冲突</id>
        <link href="https://joserccblog.github.io/post/2018-04-08-mas_updateConstraints更新约束引起的约束冲突">
        </link>
        <updated>2017-12-22T01:45:03.000Z</updated>
        <content type="html"><![CDATA[<hr>
<h2 id="typora-copy-images-to-ipic">typora-copy-images-to: ipic</h2>
<h2 id="问题描述">问题描述</h2>
<p>最近发现购物车的列表非常的卡顿，才觉得解决约束冲突是多么重要的。</p>
<ul>
<li>
<p>存在多店铺活动的</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2018-04-06-79DF33F7-1626-4FFD-9B01-1B115617F764.png" alt="79DF33F7-1626-4FFD-9B01-1B115617F764"></p>
</li>
<li>
<p>不存在店铺活动</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2018-04-06-671020DE-4D31-49ED-8391-E4BC68406408.png" alt="671020DE-4D31-49ED-8391-E4BC68406408"></p>
</li>
</ul>
<p>在这个试图上面 <code>Promo</code> 按钮和后面的文字后面可能会出现一个小图标。</p>
<p>初始化显示文字的 <code>UILable</code> 约束如下。</p>
<pre><code class="language-objective-c">label.leading.equalTo(promoButton.mas_traling).offset(10);
</code></pre>
<p>最后获取到服务器信息之后我是下面的更新约束。</p>
<pre><code class="language-objective-c">if(isCrossShop) {
    label.leading.equalTo(crossShopImageView.mas_traling).offset(10);
} else {
    label.leading.equalTo(promoButton.mas_traling).offset(10);
}
</code></pre>
<p>代码看是没什么问题的，并且界面表现都是十分正常的。为什么输出会报约束冲突呢。</p>
<p>后来发现约束冲突出现的原因如下。</p>
<ul>
<li>
<p><code>mas_updateConstraints</code>使用初始化没有出现的约束。</p>
<p>比如初始化 <code>UIlabel</code> 初始化的时候只设置了 <code>Top</code> 和 <code>leading</code> 约束。</p>
<p>但是之后更新添加了 <code>width</code> 约束，这样就回报约束冲突。</p>
</li>
<li>
<p><code>mas_updateConstraints</code>更新约束对比对象</p>
<p>比如初始化参照 <code>View1</code>的右侧约束，更新约束的时候换成了 <code>View2</code>就造成了约束冲突。</p>
</li>
</ul>
<p>我们上面的约束冲突就是第二种冲突约束。</p>
<h2 id="解决办法">解决办法</h2>
<p>如果更新约束 需要设置新的约束条件和更换约束对比对象，可以使用<code>mas_remakeConstraints</code>这个方法。</p>
<p><code>mas_remakeConstraints</code>这个对比更新约束会慢很多，但是造成约束卡很多。还是<code>mas_remakeConstraints</code>比较好。</p>
<p>​</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UIStackView在iOS11上可能会影响子试图的布局]]></title>
        <id>https://joserccblog.github.io/post/2017-12-20-uistackview在ios11上可能会影响子试图的布局</id>
        <link href="https://joserccblog.github.io/post/2017-12-20-uistackview在ios11上可能会影响子试图的布局">
        </link>
        <updated>2017-12-19T23:13:33.000Z</updated>
        <content type="html"><![CDATA[<p>我为什么要说<code>UIStackView在iOS11上可能会影响子试图的布局</code>呢？因为我大概找到了因为 <code>UIStackView</code> 而引发出来的问题，没有找到问题的关键所在，也没有找到解决方法。</p>
<p>事情大概是这个样子的，我因为要做一款个人的 <code>APP</code>，就借鉴了一下滴滴出行的 <code>UI</code> 界面，设计成下面的样子。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-20-5D870329-235A-447B-81AE-0CE4C72CFCEE.png" alt="5D870329-235A-447B-81AE-0CE4C72CFCEE"></p>
<p>当时就准备把下面的做成一个控件</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-20-5365C951-77C0-4A2B-886E-9A827CD183AA.png" alt="5365C951-77C0-4A2B-886E-9A827CD183AA"></p>
<p>我说干就那就干，立马在 <code>Github</code> 立项，开始风风火火的制作起来。(这就是我的 <code>Github</code> 那么多废弃的坑了)</p>
<p>https://github.com/Share-Parking/ShareParking-Swich</p>
<p>大家可以前往 <code>developer</code> 分支查看此项目的进度，为了更加方便封装。我使用了 <code>Framework</code> 的方式来做这个控件。</p>
<p>使用 <code>Framework</code> 这种方式其实有几个好处的，我慢慢的说一下究竟有哪些好处。</p>
<ol>
<li>可以支持 <code>Playground</code> 进行界面的边写边调试</li>
<li>支持 <code>Swift</code> 转换成 <code>OC</code> 在 <code>OC</code> 工程运行</li>
<li>可以使用 <code>Carthage</code> 很方便的打包成 <code>Framework</code> 接入 <code>Carthage</code>和 <code>Cocoapods</code></li>
<li>可以一边练习 <code>Swift</code> 一边写轮子</li>
</ol>
<p>唯一的缺点是不支持 <code>iOS8</code>以下，没事我这个轮子还不支持 <code>iOS9</code>以下呢？</p>
<p>起先在我 <code>Playground</code> 运行显示和交互十分的正常，但是在例子里面就表现的不正常了。</p>
<p>我觉得这个不正常应该来源于我的习惯，如果不是因为我的习惯，绝对还发现不了。</p>
<p>我的习惯测试控件都喜欢把初始的位置设置到<code>(0,0)</code>。</p>
<p>下面是我测试代码</p>
<pre><code class="language-swift">let swich = SPSwich(frame: CGRect(x: 0, y: 0, width: 200, height: 100))
self.view.addSubview(swich)
</code></pre>
<p>这两句代码是我从 <code>Playground</code>直接拷贝过来的，<code>Playground</code> 表现的结果如下。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-20-073252.gif" alt="2017-12-20 15_32_36"></p>
<p>但是同样的代码放在我的例子上面就表现成下面的样子了。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-20-073516.gif" alt="2017-12-20 15_34_34"></p>
<p>我们可以看到当我们进行切换的时候，我们的试图明显的被挤压了。我们目测被挤压的高度应该是<code>20</code>高度。</p>
<p>为什么会被<code>20</code>高度呢？<code>20</code>高度代表着什么呢？</p>
<p>一个大胆的想法出现在我的脑海里面，那就是是不是<code>20</code>代表着<strong>状态栏的高度</strong>，如果我们设置的位置在导航栏的下面，就可以不偏移了。</p>
<p>我带着半信半疑的态度，立马把代码设置成下面的样子。</p>
<pre><code class="language-swift">let swich = SPSwich(frame: CGRect(x: 0, y: 20, width: 200, height: 100))
self.view.addSubview(swich)
</code></pre>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-20-073945.gif" alt="2017-12-20 15_39_30"></p>
<p>果然验证了我的猜想，但是为什么突然就出现影响子试图的位置和大小了呢？</p>
<p>我们之前如果想设置全屏的布局就需要设置一个属性，那就是下面的代码。</p>
<pre><code class="language-swift">self.automaticallyAdjustsScrollViewInsets = false
</code></pre>
<p>但是不幸的是这个属性竟然在 <code>iOS11</code>以上被废弃了，改用了<code>UIScrollView</code> 一个新的属性进行代替。</p>
<pre><code class="language-swift">@available(iOS 11.0, *)
open var contentInsetAdjustmentBehavior: UIScrollViewContentInsetAdjustmentBehavior
</code></pre>
<p>虽然有替代的方案可以解决，但是我们这个例子当中并没有用到 <code>UIScrollView</code>。</p>
<p>我们假如继续大胆的猜测，会不会我们使用 <code>UIStackView</code> 的影响导致的呢。</p>
<p>我们为了验证这个猜想，立马去掉了我们使用 <code>UIStackView</code> 的布局，使用设置 <code>Frame</code>的方式设置我们里面的子试图。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-20-074715.gif" alt="2017-12-20 15_47_06"></p>
<p>我们换成常规的使用 <code>Frame</code> 进行布局的时候，果然发现表现正常了。</p>
<p>到目前位置，暂没有找到因为 <code>UISatckView</code> 里面那个属性在 <code>iOS11</code>废弃了，导致这个问题的出现。</p>
<p>现在的解决办法有两个:</p>
<ul>
<li><strong>使用手动计算的方式布局子试图</strong></li>
<li><strong>使用设置约束设置子试图</strong></li>
<li><strong>继续使用 UIStackView 但是布局在 y &gt;= 20</strong></li>
</ul>
<p>在开发的过程中，直接布局在 <code>y&lt;20</code>上面。并且使用 <code>UIStackView</code> 布局应该少之又少。</p>
<p>这虽然是一个问题的存在，但是不影响大家平时开发。</p>
<p>如果那个大神知道这个问题什么原因导致并知道解决办法的话，可以联系我帮助修正。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我是为什么因为@饱醉豚离开简书]]></title>
        <id>https://joserccblog.github.io/post/2017-12-13-我是为什么因为@饱醉豚离开简书</id>
        <link href="https://joserccblog.github.io/post/2017-12-13-我是为什么因为@饱醉豚离开简书">
        </link>
        <updated>2017-12-12T18:19:11.000Z</updated>
        <content type="html"><![CDATA[<p>我是为什么因为<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>离开简书？</p>
<p>这应该不是一个伪命题，搜一下关于因为<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>离开简书是日趋增多。这不伐<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>对于程序员黑的事情，加上<a href="http://www.jianshu.com/u/y3Dbcz">简叔</a>跟风为了一己私利维护网站蛀虫的存在。</p>
<p>我是很早就开始写小说了，大概在2005年的时候就开始了。当时起点也是类似<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>蛀虫的存在。</p>
<p>虽然这么作者给起点带来了流量，但是无疑是一种恶性，并且不是良性的存在。最后起点还是痛下心来整改了这些所谓的蛀虫。</p>
<p>我起先写小说是因为我爱好文学，后来做了程序员是为了生活。我抱起了文学，却站不起来。我站起来，却触摸不到文学。</p>
<p>这个世界是残酷的，这个世界是需要生存的。我们在理想和生存之间必须选择一种的话，那必须是生存。</p>
<p>所以虽然我是程序员，但是我的骨子里面却不喜欢别人这么称呼我。我总觉得程序员和我理想的文艺小说家差距太大。</p>
<p>但是这并不能成为让别人诋毁我的一个特点，我成为程序员也是为了养活自己。我虽然不觉得程序员是一种光荣的职业，但是也不会诋毁程序员。</p>
<p>因为这个行业让我养活了我自己，养活了我的家人，包括目前正在健康成长的女儿。</p>
<p>在<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>的众多文章当众，骂程序员的占了一大半。我不知道是什么原因让<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>一直痛恨程序员。</p>
<p>也许是<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>的老婆和一个做程序员的出轨了，<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>看到了才会这么激动。或许是说<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>的家人被一个程序员骑电车撞死了，才会这么的愤慨。</p>
<p>可能大家还不太了解<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>怎么污言秽语的侮辱程序员这个行业，大家可以看一下截图。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-13-D6417B4A-45E2-49C4-80BB-1D2B912C1DCF.png" alt="D6417B4A-45E2-49C4-80BB-1D2B912C1DCF"></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-13-2562CF46-9A4F-4834-8229-B3C6718E2949.png" alt="2562CF46-9A4F-4834-8229-B3C6718E2949"></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-13-26A58DDB-3D3B-4FB7-A0DB-C7E64D46423C.png" alt="26A58DDB-3D3B-4FB7-A0DB-C7E64D46423C"></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-13-1B8022C9-33C0-468A-BB19-C063657FD0A4.png" alt="1B8022C9-33C0-468A-BB19-C063657FD0A4"></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-13-D2CA458B-7B35-45FB-A9A7-CA8026B8ABF8.png" alt="D2CA458B-7B35-45FB-A9A7-CA8026B8ABF8"></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-13-9EE08E20-BD98-43BF-95F1-CFF5209C34A6.png" alt="9EE08E20-BD98-43BF-95F1-CFF5209C34A6"></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-13-6E9B12E7-7C3D-4E18-A004-2D86D348DF58.png" alt="6E9B12E7-7C3D-4E18-A004-2D86D348DF58"></p>
<p>这些都是<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>怎么侮辱程序员的证据，我在想程序员怎么招惹你了，是挖你家祖坟了？还是强奸你家十八代了？</p>
<p>看着头像是一个英俊的中年大叔，原来确实这么污浊不堪，低素质的一个人。</p>
<p>我一直坚信一个道理，一个人经常的作恶引起公愤，总会有人出面踩在他的脸上。一个人经常的行善，总会被他人记住。</p>
<p>我觉得如今的<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>已经作恶到极限了，我劝你<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>最好之后之后左顾右盼一下。不是被车撞死就是被其他人打死。</p>
<p>这是真的，我不骗你，你不知道我们北方人多么敢爱敢恨。</p>
<p>对于<a href="http://www.jianshu.com/u/y3Dbcz">简叔</a>我不知道说什么才好，我不知道<a href="http://www.jianshu.com/u/y3Dbcz">简叔</a>当初创办简书的目的是什么？但是我清晰的记得简书当初是靠着一大批程序员逐渐成型的。</p>
<p>现在<a href="http://www.jianshu.com/u/y3Dbcz">简叔</a>现在做了什么，为了他的一己私欲偏袒维护着简书的蛀虫，完全生活在自己黄庭集院。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-13-9AD2E81B-E8DB-4F53-A6A1-CF39F627EA47.png" alt="9AD2E81B-E8DB-4F53-A6A1-CF39F627EA47"></p>
<p>这是<a href="http://www.jianshu.com/u/y3Dbcz">简叔</a>对于<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>的赞美之词，多么的好话，但是我隔着屏幕闻到了一股资本的味道。</p>
<p>我觉得应该是铜臭相吸，为什么<a href="http://www.jianshu.com/u/y3Dbcz">简叔</a>那么支持<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>，可能是一对 CP 或者是一种货色或者是同一路人吧。</p>
<p>我并不觉得<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>他的文章多么的多元，多么的真实。确实很新鲜，因为<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>所说的都在等于放屁。</p>
<p>我并不觉得<a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>的文章多么有营养，呸！垃圾都算不上，这都是文学的垃圾，文学中的耻辱而已。</p>
<p>从简书最几年的变化，我预测简书走不多远。</p>
<p>有句话说的话，不忘初心，方得始终！简书在自己初心的路上渐行渐远，距离贪婪和欲望越来越近。</p>
<p>在<a href="http://www.jianshu.com/u/y3Dbcz">简叔</a>的眼中，他看不清前方迷雾是什么，到底迷雾散去。脚下是不是万丈深渊！</p>
<p>一个只注重商业写作，容不得其他人爱好写作的平台坚持不了多久。</p>
<p>我不否认一个平台的发展确实需要一个商业写作写手，但是平台的万千基石确实靠着喜爱写作的作者支撑起来的。</p>
<p><a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>最近的文章都离不开程序员三个字，看到的程序员从简书渐渐的褪去。这已经属于一个危险的信号。</p>
<p>就好比一个强奸犯，当地的政府还为强奸犯找说辞。说强奸犯的方法多么的多元，新鲜，真实。而且这个强奸犯每天坚持每日强奸，从不放弃。</p>
<p>呵呵，下面是简叔的核心思想。</p>
<pre><code>很多人可能不太理解饱醉豚在我心中的存在。坦白讲，我也没有享受到被他强奸的滋味。但是他对我有很重要的意义。1. 牢记简书一直强奸别人眼球和精神威力年。如果哪天简书开始封杀饱醉豚，那将是偏离初心的开端。如果仅仅因为饱醉豚的存在而导致简书继续耍流氓，那一定是我们不行了。2. 高度契合多姿势 多方法  多流氓。他可能是少数之中坚持强奸别人精神的人，大部分人在都很城市。他有很多“新鲜”的姿势，大部分人都守本分。他所说的部分技巧，确实可能我也受不了；但他说说的另一姿势，我们会非常享受。他支撑起了 “多元”化方式。当时在确定简书的污浊思想时候，我们讨论的时候已经有了老饱。但讨论出的结果，后来一想，老饱是高度配合的。3. 让我们谦虚弯腰。我们大多数人都对此会心一笑。对简书这样的垃圾产品来说，运营团队的献身是重要的。每个人都有自己的姿势，总是认为自己比作者厉害，或者说自己认为好的他就是好的，都是很好的想法。老饱的存在时刻提醒着我们垃圾是什么样子。在他开始日奸的时候，我写了一篇《饱醉豚在简书的日奸计划》。一年过去了，他真的做到了。老饱，真成为了文学界的人渣了。帖子别删。

作者：简叔
链接：http://www.jianshu.com/p/eba255074765
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p><a href="http://www.jianshu.com/u/rHypHw">饱醉豚</a>请收起你的恶，放下屠刀立地成佛。善有善报恶有恶报，不是不报时间未到。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一次一知半解的学习UIStackView]]></title>
        <id>https://joserccblog.github.io/post/2017-12-01-一次一知半解的学习uistackview</id>
        <link href="https://joserccblog.github.io/post/2017-12-01-一次一知半解的学习uistackview">
        </link>
        <updated>2017-11-30T23:39:08.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-29-025249.jpg" alt=""></p>
<h2 id="arrangedsubviews">arrangedSubviews</h2>
<p>图中的四个子试图可以通过 <code>arrangedSubviews</code>属性进行设置。</p>
<p>我们可以通过初始化方法进行设置 <code>arrangedSubviews</code>。</p>
<pre><code class="language-swift">let arrangedSubviews = [UIView()]
let stackView = UIStackView(arrangedSubviews: arrangedSubviews)
</code></pre>
<p>添加一个试图到 <code>arrangedSubviews</code>数组最后。</p>
<pre><code class="language-swift">let addNewView = UIView()
stackView.addArrangedSubview(addNewView)
</code></pre>
<p>从 <code>arrangedSubviews</code>移除指定的试图。</p>
<pre><code class="language-Swift">stackView.removeArrangedSubview(addNewView)
</code></pre>
<p>我们还可以交换一个试图所在的位置到0</p>
<pre><code class="language-swift">stackView.insertArrangedSubview(addNewView, at: 0)
</code></pre>
<h2 id="axis">axis</h2>
<p>我们想怎么知道试图是按照横向排列还是纵向排列的呢？我们有一个枚举可以使用。</p>
<pre><code class="language-swift">open var axis: UILayoutConstraintAxis
</code></pre>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-29-063859.jpg" alt=""></p>
<p>我们可以通过设置 <code>axis</code>为 <code>.horizontal</code>为横向布局</p>
<pre><code class="language-swift">stackView.axis = .horizontal
</code></pre>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-29-064622.jpg" alt=""></p>
<p>我们可以设置 <code>axis</code>为 <code>.vertical</code>为纵向布局</p>
<pre><code class="language-swift">stackView.axis = .vertical
</code></pre>
<p>现在我们知道怎么设置横向布局还有纵向布局，我们想做下面的试图结构该如何做呢。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-29-070602.png" alt=""></p>
<p>红色的试图大小为 <code>375x50</code>,中间的间距是 <code>20</code>。白色的试图大小为 <code>51x33</code>;</p>
<pre><code class="language-swift">import UIKit
import PlaygroundSupport

class MyViewController : UIViewController {
    override func loadView() {
        let view = UIView()
		view.frame = CGRect(x: 0, y: 0, width: 375, height: 676)
        view.backgroundColor = .white

		let backgroundView = UIView()
		backgroundView.backgroundColor = #colorLiteral(red: 0.5725490451, green: 0, blue: 0.2313725501, alpha: 1)
		backgroundView.bounds = CGRect(x: 0, y: 0, width: 375, height: 50)
		backgroundView.center = view.center
		view.addSubview(backgroundView)

		var arrangedSubViews:[UIView] = []

		for _ in 0 ..&lt; 5 {
			let subView = UIView()
			subView.backgroundColor = #colorLiteral(red: 0.501960814, green: 0.501960814, blue: 0.501960814, alpha: 1)
			arrangedSubViews.append(subView)
		}

		let stackView = UIStackView(arrangedSubviews: arrangedSubViews)
		stackView.frame = CGRect(x: 20, y: 9, width: 375 - 40, height: 50 - 18)
		stackView.axis = .horizontal
		stackView.alignment = .fill
		stackView.distribution = .fillEqually
		stackView.spacing = 20
		backgroundView.addSubview(stackView)

        self.view = view
    }
}
// Present the view controller in the Live View window
PlaygroundPage.current.liveView = MyViewController()
</code></pre>
<p>上面的代码可以放在 <code>Playground</code> 看运行的效果。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-29-5441F16D-7ADB-47A9-A422-41132955C892.png" alt="5441F16D-7ADB-47A9-A422-41132955C892"></p>
<p>我们可以在上面的代码中发现了三个起到决定作用的属性分别是 <code>alignment</code> <code>distribution</code></p>
<p><code>spacing</code>。</p>
<h2 id="alignment">alignment</h2>
<p>关于 <code>alignment</code>是一个枚举。</p>
<h3 id="fill">fill</h3>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-29-074402.png" alt=""></p>
<p><code>fill</code>是铺满的样式。在保证最小间距的情况下，铺满整个 <code>UIStackView</code>。这个模式之下，并不是均等的分割平铺，除非设置下面的属性。</p>
<pre><code class="language-swift">stackView.distribution = .fillEqually
</code></pre>
<h3 id="top">top</h3>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-29-9852AED3-1E0A-4CB7-810E-0E7009488FF3.png" alt="9852AED3-1E0A-4CB7-810E-0E7009488FF3"></p>
<p><code>top</code>是基于顶部对其，下面根据再自动约束。</p>
<h3 id="bottom">bottom</h3>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-29-091447.png" alt=""></p>
<p><code>bottom</code>是基于底部对其，上面再进行自动约束。</p>
<p>对于横向布局来说</p>
<pre><code class="language-swift">leading = top
trailing = bottom
</code></pre>
<p>横向布局设置左对齐和右对齐无法生效。</p>
<h3 id="center">Center</h3>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-29-092108.png" alt=""></p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-29-988F0286-3A9B-4A1A-A06A-73E5BFBA4198.png" alt="988F0286-3A9B-4A1A-A06A-73E5BFBA4198"></p>
<p><code>center</code>当为横向布局的时候，约束像上下两端延伸。如果是纵向约束的时候，约束像左右两端延伸。</p>
<h3 id="leading">leading</h3>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-29-092608.png" alt=""></p>
<p><code>leading</code>当布局方式为纵向排列时候，按照左侧对其。</p>
<h3 id="trailing">trailing</h3>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-29-094240.png" alt=""></p>
<p><code>trailing</code>是在纵向布局情况下，按照右侧进行布局。</p>
<h3 id="firstbaseline">firstBaseLine</h3>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-30-020705.png" alt=""></p>
<p><code>firstBaseLine</code>只针对于横向排列布局有效，是针对数组第一个试图,如果不是文本就按照顶端开始对其，是文本按照文本下端对其。</p>
<h3 id="lastbaseline">lastBaseLine</h3>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-30-510A083F-F423-4558-B970-4BEEC02F904F.png" alt="510A083F-F423-4558-B970-4BEEC02F904F"></p>
<p><code>lastBaseLine</code>也是针对于横向排列布局有效，是针对数组第一个试图,如果不是文本就按照底部开始对其，是文本按照文本底部对其。</p>
<h2 id="distribution">distribution</h2>
<p><code>distribution</code>这个属性是决定子试图布局的最关键因素。</p>
<h3 id="fill-2">fill</h3>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-30-0AF4AB7D-ED07-4631-99EB-969FB5F77876.png" alt="0AF4AB7D-ED07-4631-99EB-969FB5F77876"></p>
<p><code>fill</code>模式是按照设置的间距，之后根据子试图全部铺满整个 <code>UIStackView</code>。在这里我们要提到一个方法那就是 <code>intrinsicContentSize</code>。</p>
<p><code>intrinsicContentSize</code>指代一个试图最适合的大小，对于 <code>UIImageView</code> <code>UILabel</code> <code>UIButton</code>都是可以系统计算 <code>intrinsicContentSize</code>大小的。</p>
<p>但是对于 <code>UIView</code>是系统无法知道 <code>intrinsicContentSize</code>大小。我们就需要子类重写 <code>intrinsicContentSize</code>这个方法让系统知道最适合的试图大小是多少。</p>
<p>我们为什么要知道 <code>intrinsicContentSize</code>的大小，首先我们研究 <code>fill</code>形式试图布局的计算公式。</p>
<p>我们按照上图所以计算</p>
<pre><code class="language-swift">let width = View1.intrinsicContentSize.width + spance + View2.intrinsicContentSize.width + spance + View3.intrinsicContentSize.width + spance + View4.intrinsicContentSize.width
</code></pre>
<p>当我们计算出的 <code>Width</code>已经超过我们 <code>UIStackView</code>的宽度的时候，我们会按照优先级，压缩优先级比较低的试图。</p>
<p>如果优先级都一样，那么我们会先保证 <code>arrangedSubviews</code>数组里面排序在前面的试图展示，之后压缩排序在后面的试图。</p>
<p>当我们计算出的 <code>width</code>不足以铺满我们 <code>UIStackView</code>宽度的时候，我们会让优先级别叫高的试图优先按照正确的试图显示，当优先级一样的时候，我们会优先让 <code>arrangedSubviews</code>索引在后面试图优先按照正常尺寸显示，最前面进行拉伸。</p>
<p>这里先讲解一下优先级，优先级分为抗压缩(<code>Content Compression Resistance Priority</code>)还有抗拉伸(<code>Content Hugging Priority</code>)。</p>
<h4 id="content-compression-resistance-priority">Content Compression Resistance Priority</h4>
<p>抗压缩的优先级: <code>750</code> 优先级越高越不容易被压缩。</p>
<h4 id="content-hugging-priority">Content Hugging Priority</h4>
<p>抗拉伸的优先级: <code>250(251)</code> 优先级越高越不容易被拉伸。</p>
<blockquote>
<p>这里有个奇怪的问题 代码创建优先级默认为<code>250</code> 但是 <code>XIB</code> 创建的优先级别为<code>251</code>。</p>
</blockquote>
<p>我们往 <code>UIStackView</code>添加三个 <code>UIView</code>，分别是红蓝黄。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-01-030535.png" alt=""></p>
<p>我们发现能可见的试图只有 <code>蓝色</code>的试图，这到底是怎么的回事呢？</p>
<p>因为对于 <code>UIView</code>来说，系统无法计算试图的大小，会返回默认为<code>(-1,-1)</code>。</p>
<p>对于显示来说，<code>(-1,-1)</code>是按照 <code>（0，0）</code>计算的。为什么出现蓝色，我也是猜测，但是经过几次实验来说，大概得出来这个结论。</p>
<blockquote>
<p>对于 <code>UIStackView</code>布局的数组来说，</p>
<p>如果数组只有一个试图的时候是铺满整个 <code>UIStackView</code>.</p>
<p>如果数组试图大于一个的时候，左侧的边距是最后第二试图和第一个试图间隙想加。显示最后第二个试图。</p>
<p>就按照上面的例子来说。</p>
<p>最后第二个元素是 <code>蓝色</code>的，所以显示出来的是蓝色试图的。和第一个试图只有一个间隙，我们设置间隙最小 <code>10</code>。那么蓝色试图左侧的间隙是是 <code>1*10</code>间距，右侧就是和最后一个的间隙 <code>10</code>。</p>
<p>如果只有一个试图的时候。</p>
<p>因为不存在倒数第二个试图，直接显示唯一的一个。一个试图的左侧和右侧也没有试图，那就是没有间距，全部铺满。</p>
</blockquote>
<p>为了证明我们 <code>intrinsicContentSize</code>这个值决定 <code>UIView</code>在 <code>UIStackView</code>的布局，我们就用自定义 <code>UIView</code>一个类，重写 <code>intrinsicContentSize</code>方法，控制 <code>红</code>，<code>黄</code>，<code>蓝</code>的大小为<code>(100,0)</code></p>
<p>为什么我们不设置<code>高度</code>，因为对于横向布局铺满来说。设置高度已经没有什么意义了，布局只关系宽度。</p>
<p>我们设置 <code>UIStackView</code>的宽度为<code>320</code>，间距为<code>10</code>。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-01-032856.png" alt=""></p>
<p>我们发现我们的三个试图竟然全部的展示出来，因为 <code>100 + 10 + 100 +10 + 100 = 320</code></p>
<p>我们设置的大小和间距正好等于我们设置 <code>UIStackView</code>的宽度。</p>
<p>我们设置一下 <code>UiStackView</code>小于我们计算的宽度，设置为 <code>280</code>。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-01-033133.png" alt=""></p>
<p>当我们设置<code>UIStackView</code> 宽度不够的时候，我们的小黄被压缩了。因为要优先的保证间距，三个试图的优先级是一样的，所以小黄的只能委屈的被压缩了。</p>
<p>小黄再想凭什么我就被欺负，小红和小蓝说因为你来的比我们晚。后来小黄因为关系，一下子级别比小红和小蓝都高。没法再欺负了，怎么提升级别，看下面。</p>
<p>因为小黄默认抗压缩级别是<code>750</code>，小黄通过关系提升到<code>1000</code>，让你们还欺负我。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-01-034402.png" alt=""></p>
<p>我们从结果来看，我们的小黄自从提升级别之后再也不被欺负，但是小蓝成为下一个挤压。</p>
<p>我们再把小黄的级别降下来，现在让容器变大，宽度变成<code>375</code>。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-01-054752.png" alt=""></p>
<blockquote>
<p>因为 <code>Playground</code> 里面的预览模拟器屏幕的宽度就是375</p>
</blockquote>
<p>我们发现小蓝和小黄已经恢复正常了，但是红色竟然被拉长了。这是什么原因呢？</p>
<p>我们想让小蓝拉伸，因为抗拉伸优先级越高越被拉伸，我们设置小蓝如下。</p>
<pre><code class="language-swift">view2.setContentHuggingPriority(.fittingSizeLevel, for: .horizontal)
</code></pre>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-01-2ADD4DC7-004C-42FC-A244-FCA611D65B66.png" alt="2ADD4DC7-004C-42FC-A244-FCA611D65B66"></p>
<p>我们可怜的小蓝果然变得臃肿了起来，因为 <code>fittingSizeLevel</code> 的优先级为<code>50</code>，是最先考虑被拉伸的。</p>
<p>从上面我们得出一个结论如下：</p>
<blockquote>
<p>当我们设置为 <code>fill</code> 模式填充的时候</p>
<p>如果全是 <code>UIView</code> 计算不出来实际大小，就展示倒数第二个试图，如果只有一个就全部铺满</p>
<p>如果宽度不够，就优先压缩优先级比较低的试图，其次从最后一个试图进行压缩。</p>
<p>如果宽度足够，就优先拉伸优先级比较低的试图，其次从最前面的试图进行拉伸。</p>
</blockquote>
<h3 id="fillequally">fillEqually</h3>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-01-060625.png" alt=""></p>
<p>这个模式是让所有的试图进行平分,如果宽度只够显示最小的间隙就只显示间隙。</p>
<p>这个模式不用计算实际大小，也不用设置优先级。</p>
<h3 id="fillproportionally">fillProportionally</h3>
<p>这个是按照实际大小按照比例进行分配大小，暂时没找到分配到底有什么规律。</p>
<h3 id="equalspacing">equalSpacing</h3>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-01-2F931DF6-A6B3-42DE-A30F-DA0DD851809B.png" alt="2F931DF6-A6B3-42DE-A30F-DA0DD851809B"></p>
<p>这个模式是按照实际大小布局，如果宽度足够就平均拉伸间距。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-01-064156.png" alt=""></p>
<p>如果宽度不足，就按照优先级之后试图顺序进行压缩。</p>
<h3 id="equalcenter">equalCenter</h3>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-01-812EFFAE-09C6-4B64-90E1-685051F7B5A6.png" alt="812EFFAE-09C6-4B64-90E1-685051F7B5A6"></p>
<p>保证最小间距情况下，按照最适合的大小，之后按照中心点距离相等进行排列。排列出来的间距不一定相等，但是最小必须等于设置的最小间距。</p>
<p>如果宽度小于设置的宽度，那么按照优先级之后按照试图顺序压缩试图。</p>
<p>如果宽度不够，就优先排列宽度最小的一边。如果最小在左侧就从左侧布局</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-01-071842.png" alt=""></p>
<p>如果最小的在右侧就从右侧布局</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-01-071700.png" alt=""></p>
<h2 id="islayoutmarginsrelativearrangement">isLayoutMarginsRelativeArrangement</h2>
<p>是否允许启用边缘布局，默认是 <code>false</code> 全部铺满。</p>
<p>假设我们设置<code>isLayoutMarginsRelativeArrangement</code>为 <code>true</code>,边距都为10。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-01-072349.png" alt=""></p>
<h2 id="setcustomspacing">setCustomSpacing</h2>
<p>可以设置某个试图后的间距，这个设置优先级比默认间距优先级高。比如我们设置红色和蓝色中间的间距为<code>5</code>。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2017-12-01-073125.png" alt=""></p>
<p>关于 <code>UIStackView</code> 今天算是研究完，但是文章中有很多不正确的地方，大家发现不正确的地方及时提醒我纠正。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[想要漂亮的蒙版指引吗？跟着我手把手的教你写出来]]></title>
        <id>https://joserccblog.github.io/post/2017-11-27-想要漂亮的蒙版指引吗？跟着我手把手的教你写出来</id>
        <link href="https://joserccblog.github.io/post/2017-11-27-想要漂亮的蒙版指引吗？跟着我手把手的教你写出来">
        </link>
        <updated>2017-11-26T23:43:54.000Z</updated>
        <content type="html"><![CDATA[<p>最近版本的一个需求是给首页添加新人蒙版，类似的效果图如下图所示。</p>
<p><strong>首页第一层蒙版的效果图</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-c90dd6f8e25f8af9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首页蒙层"></p>
<p><strong>首页第二层的蒙版效果图</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-3760d05d85f1d5af.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首页蒙层2"></p>
<p><strong>个人中心的蒙版效果图</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-2cac899c38c495bf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用户中心蒙层"></p>
<blockquote>
<p>其实我觉得这些新人引导完全是没必要的，对于一个知道用 APP 买东西的用户怎么看不明白这些标志，还要用蒙版引导告诉他。</p>
</blockquote>
<p>既然接到了这个需求，那么就需要做出来，第一眼看上去确实有点难。当时安卓已经找到了对应的库，十分容易的做这个需求了。</p>
<p>我当时的第一个想法是，既然安卓有类似的库，那么 <code>iOS</code>应该也有类似的库。我当即就在最大的成人同性交友网站 <code>GitHub</code> 查找对应关键词去找对应的蒙版指引的库。</p>
<p>虽然是找到了，但是被别人 <code>Star</code>的星很少，或者是有几百的下载出来运行<code>Demo</code> 就崩溃了，导致我第一时间严重怀疑这个库的健壮性。</p>
<p>既然没有找到可以信赖的轮子，那就自己研究一下，毕竟之前没有做过。之前一致觉得中间镂空的是用周围很多块不露空的组合在一起形成的，所以很复杂的镂空我都觉得很难弄。</p>
<p>这个需求我之前的想法一定是做不出来的，就百度一下蒙版指引的做法。在简书上面看到一个前辈写的教程，只有怎么做出来的部分关键的代码，是没有例子的。</p>
<p>那个前辈说，想问他要例子是没有的，如果想要，自己就动手写一个。我觉得这个前辈说的很少，只有自己亲手写一个才可以理解的更深。</p>
<p>经过查询，我找到了做这个功能一个重要的属性。</p>
<pre><code class="language-objective-c">@property(nullable, strong) CALayer *mask;
</code></pre>
<p>这个属性解释的通俗易懂就是其他的 <code>CALayer</code> 是添加到哪里，那里就不显示。这个 <code>mask</code> 的 <code>CALayer</code> 是添加到哪里，那里就可以显示出来。</p>
<p>既然有了这个属性，那么就好办多了。</p>
<p>我们可以观察上面的三张效果图，争取找到最多的共同点，我们可以封装一个组件，用于支持我们三张蒙版指引。</p>
<p><strong>发现的共同点</strong></p>
<ul>
<li>有一个全屏的半透明的蒙版试图</li>
<li>每一个指引有一个透明的圈(不管是椭圆还是圆形)</li>
<li>每一个圈外面都有一个虚线圈</li>
<li>每一个指引都有一个指引剪头</li>
<li>每一个指引都有一段指引的文字</li>
</ul>
<p><strong>发现的不同点</strong></p>
<ul>
<li>椭圆或者是圆形</li>
<li>有按钮或者没按钮</li>
</ul>
<blockquote>
<p>此处我就要吐槽一下这个设计交互。我们发现最后一个是没有按钮的，那么意味着我们点击任何地方就可以让蒙版消失。</p>
<p>如果点击任何地方就可以让蒙版消失，那么首页的两张蒙版上面的按钮真的有保留的意义了。</p>
<p>如果只允许个人中心的蒙版可以点击任何地方消失，那么这个需求的交互就不统一了。最后是三张蒙版点击任何地方都消失</p>
</blockquote>
<p>我们可以把相同的地方做成一个基类，不同的地方可以在对应的子类进行修改即可。</p>
<p>我们创建一个继承于 <code>UIView</code> 的类名字叫做<code>GBBaseMaskView</code>类用于封装我们指引的共同点。</p>
<p>我们设置子类试图的背景颜色为黑色 0.8透明</p>
<pre><code class="language-objective-c">self.backgroundColor = [UIColor colorWithWhite:0 alpha:0.8];
</code></pre>
<p>因为我们的指引目前只有两种，那就是椭圆和原型。我们就设置一个枚举用于区分这两种类型。</p>
<pre><code class="language-objective-c">/**
 * 创建蒙版的类型

 - GBMaskItemStyleCircle: 圆形
 - GBMaskItemStyleOval: 椭圆
 */
typedef NS_ENUM(NSUInteger, GBMaskItemStyle) {
    
    GBMaskItemStyleCircle,
    GBMaskItemStyleOval,
};
</code></pre>
<p>我们给 <code>UIView</code> 添加点击事件，用于点击可以让蒙版消失。</p>
<pre><code class="language-objective-c">@weakify(self);
[self addTapGestureWithComplete:^(UIView * _Nonnull view) {
    @strongify(self);
    [self actionButtonClick];
}];
</code></pre>
<p>此处我们用到的是我们基于 <code>UIView</code> 写的一个快捷添加点击事件的分类方法。</p>
<pre><code class="language-objective-c">- (void)addTapGestureWithComplete:(UIViewGestureComplete)complete {
    NSParameterAssert(complete);
    self.userInteractionEnabled = YES;
    UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapClick)];
    objc_setAssociatedObject(self, @selector(tapGesture), tapGesture, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    objc_setAssociatedObject(self, @selector(tapGestureComplete), complete, OBJC_ASSOCIATION_COPY_NONATOMIC);
    [self addGestureRecognizer:tapGesture];
}

#pragma mark - gesture method
- (void)tapClick{
    self.tapGestureComplete(self);
}

#pragma mark - property get
- (nullable UITapGestureRecognizer *)tapGesture {
    return objc_getAssociatedObject(self,_cmd);
}

- (UIViewGestureComplete)tapGestureComplete {
    return objc_getAssociatedObject(self, _cmd);
}
</code></pre>
<p>为了让界面消失之前，传递界面消失的信息给外界，我们新建一个用于异步回调的 Block</p>
<pre><code class="language-objective-c">/**
 * 操作按钮的回调
 */
@property (nonatomic, copy) void(^actionCompletionHandle)(void);
</code></pre>
<p>那么我们在<code>actionButtonClick</code>方法实现如下。</p>
<pre><code class="language-objective-c">- (void)actionButtonClick {
    if (self.actionCompletionHandle) {
        self.actionCompletionHandle();
    }
    [self removeFromSuperview];
}
</code></pre>
<p>这个类似于 <code>Alert</code>和 <code>Sheet</code>弹框的方式，我们就定义类似的方法叫做 <code>showInWindow</code>用于展示界面。</p>
<pre><code class="language-objective-c">- (void)showInWindow {
    [self setupMakeMask];
    [GB_ROOT_WINDOWS addSubview:self];
}
</code></pre>
<p>我们在这个方法分别调用了 <code>setupMakeMask</code>和用了 <code>GB_ROOT_WINDOWS</code>这个宏。现在我们抛开 <code>setupMakeMask</code>不说，咱们先说一下 <code>GB_ROOT_WINDOWS</code>这个宏这个中间曲折的故事吧。</p>
<blockquote>
<p>故事是这样开始的，可以参考下面的连接。</p>
<p><a href="http://www.jianshu.com/p/116115583b55">【已解决】UIView添加到KeyWindow上面自动会被 Release</a></p>
<p>😂忽略我 <code>GB_ROOT_WINDOWS</code>多一个 <code>s</code>单词的手误吧。</p>
<p>我们当时新下载进入首页的时候会弹出很多的弹框😀比如</p>
<ul>
<li>强制更新提示(只有 APP 无法使用 很少出现)</li>
<li>蒙版提示(没有弹出蒙版的才出现)</li>
<li>新人大礼包(三天一次)</li>
<li>注册通知确认框</li>
<li>评分弹框</li>
<li>。。。。。。</li>
</ul>
<p>大体上目前就有这么多，恰巧新用户下载就会弹出<strong>注册通知弹出框</strong>， <strong>新人大礼包弹出框</strong>， <strong>新人蒙版指引弹出框</strong>。</p>
<p>当时没有注意 <code>KeyWindow</code>这个点，所以就觉得如果全屏锁定就 <code>addSubView</code>到 <code>keyWindow</code>就可以了。</p>
<p>没想到<strong>新人蒙版指引</strong>不需要后台做控制就直接可以执行代码展示。但是 <strong>新人大礼包</strong>需要后台控制，所以会在网络回调之后才会执行弹出操作。</p>
<p>当时出现了这么的一个情况</p>
<ul>
<li>出现 <strong>新人蒙版指引</strong> <strong>注册通知弹出框</strong> <strong>新人大礼包弹出框</strong></li>
<li>出现 <strong>新人蒙版指引</strong> <strong>注册通知弹出框</strong></li>
</ul>
<p>偶尔会弹出来新人大礼包弹出框，开始我以为是接口没有回来数据，导致才无法显示出来的。</p>
<p>后来测试说<strong>安卓</strong>的就可以显示出来，就 <code>iOS</code>的不出现。我测试了接口是正常的，那么就是客户端的影响了。</p>
<p>当时的一个想法是 <code>苹果</code>对于 <code>window</code>的蒙版或许做了限制？因为首页这样一次性出现这么多，会体验不好才自动优化帮我们去除的？</p>
<p>我顺着这个想法就去做了测试用例，注释了 <code>新人蒙版指引</code>的弹出框。就只留下 <code>新人大礼包</code>和 <code>注册通知的弹出框</code>。</p>
<p>如果每次都出现，就验证了我的猜想。</p>
<p>结果也是偶尔会出现 <code>新人蒙版指引</code>，大部分测试用例都不会弹出。</p>
<p>当是看了代码写法都很正常，并且类似的写法在 <code>新人蒙版指引</code>的需求上就表现的很正常，为什么在 <code>新人大礼包</code>的需求上面就表现不正常，时而出现时而不出现的。</p>
<p>我感觉这个需求的类代码有毒。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-f08c58a06c8907a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A81BCCDC-F828-40D3-8A8F-0DD411C5BBBD"></p>
<p>后来我用 <code>Reveal</code>查看试图在什么位置的时候，发现了一个问题，那就是这个对象根本没出现。</p>
<p>如果没出现，难道被释放了。</p>
<p>于是我在 <code>dealloc</code>的方法添加了 <code>Log</code>信息，果然竟然走了 <code>dealloc</code>的方法。</p>
<p>虽然我创建的局部变量，但是我通过 <code>addSubView</code>方法已经添加到试图上面了。还被释放，我读书少，不要骗我。</p>
<p>我大胆的用了一个全局变量，这样总不会释放了吧，我看你还不出现。</p>
<p>竟然 TMD 还是没出现！！！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-5884d042a5baecbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="756EDF51-D681-4F3D-92BF-840EEDFA101B"></p>
<p>这究竟是怎么个情况，最后在群中得到的答复是我添加在 <code>keyWindow</code>是当时弹出来的 <code>Alert</code>的 <code>注册通知的弹出框</code>。</p>
<p>之后 <code>keyWindow</code>换回来之后，我们的控件就被移除，之后就被释放了。让我们用 <code>AppDelegate</code>创建的 <code>window</code>这样才保证不会出问题。</p>
<p>听完觉得说的很有道理，就改了一下，果然解决了。</p>
<p>事情到此就结束了，现在想一下，应该是我们 <code>新人蒙版指引</code>没有经过网络请求瞬间执行，当时我们的 <code>keyWindow</code>还没有改变，当 <code>新人大礼包</code>网络回调之后。我们的 <code>keyWindow</code>已经改变了。但是为什么偶尔会出现，可能原因是我们是内容，当请求足够快的时候，就可以正常的显示出来。</p>
<p>作为最后，为了这样的问题不会再出现，写代码最好规范一点用下面的宏代替我们常用的 <code>keyWindow</code>即可。</p>
<pre><code class="language-objective-c">#define GB_ROOT_WINDOWS [[[UIApplication sharedApplication] delegate] window] // 获取应用的的 Root Window
</code></pre>
</blockquote>
<p>现在关于 <code>GB_ROOT_WINDOWS</code>的梗我们已经听完了，我们继续讲解 <code>setupMakeMask</code>这个初始化蒙层的方法。</p>
<pre><code class="language-objective-c">- (void)setupMakeMask {
    if ([self conformsToProtocol:@protocol(GBBaseMaskViewDataSource)]) {
        id&lt;GBBaseMaskViewDataSource&gt; dataSource = (id&lt;GBBaseMaskViewDataSource&gt;)self;
        _maskItems = [dataSource maskViewItems:self];
    }
    [self makeMask];
}
</code></pre>
<p>我们的初始化方法，用到了一个代理源用于获取需要添加的蒙层对象。我们看一下我们写的代理。</p>
<pre><code class="language-objective-c">@protocol GBBaseMaskViewDataSource&lt;NSObject&gt;
- (NSArray&lt;GBBaseMaskViewItem *&gt; *)maskViewItems:(GBBaseMaskView *)maskView;
@end
</code></pre>
<p>我们的蒙层数据对象协议很简单，就是获取一个数组即可。这个 <code>GBBaseMaskViewItem</code>对象是什么东西呢？</p>
<p>当时是这么想的，因为配置一个对象就需要很多的数据，所以每一个就做成一个模型保留我们需要的数据。</p>
<p>这样我们需要的时候就只需要配置我们的数据模型，就会自动生成我们的蒙版。</p>
<p>因为我们的蒙版类型有两种，分别是 <code>原型</code>和 <code>椭圆形</code>。</p>
<p><strong>关于GBBaseMaskViewItem对象解释</strong></p>
<p>那么我们就写一个 <code>GBMaskItemStyle</code>类型的变量来区分到底是 <code>椭圆</code>还是 <code>原型</code></p>
<pre><code class="language-objective-c">/**
 * 蒙版风格
 */
@property (nonatomic, assign) GBMaskItemStyle maskStyle;
</code></pre>
<p>我们画圆形需要两点，一点就是原型，另外就是半径。只要有这两点，我们就可以画出一个圆。</p>
<pre><code class="language-objective-c">/**
 * 圆形的圆心
 */
@property (nonatomic, assign) CGPoint arcCenter;
/**
 * 圆形的半径
 */
@property (nonatomic, assign) CGFloat radius;
</code></pre>
<p>对于剪头图片的放置，我当时采取的方案是下面的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-c192b02bccefda1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13B4DAAE-EC53-4680-9DA0-3B5AB2D7C57F"></p>
<p>这里面有三个重要的点分别是 <code>A</code>点 <code>B</code>点 <code>C</code>点。</p>
<p>这三个重要点来帮助我们配置和实现我们上面的效果。</p>
<p><code>A</code> 点是我们画圆圈需要的中心点，也是我们需要按钮控件的中心点。半径这个我们可以设置，这个半径距离多少，我们就可以根据设计图微调即可。</p>
<p><code>B</code>点作为剪头的初始点，我们蒙版上面的剪头是让 UI 切出来的图片。图片是中规中矩的正方形，所以我们知道了 <code>B</code>点和图片的大小 就可以计算出 <code>C</code>点的位置</p>
<p>但是我们怎么知道 C 点的具体位置，我们就要引入一个数量名词 <code>象限</code>。</p>
<p>知道  <code>C</code>点距离 <code>B</code>点位于那个象限，我们就可以求出来 <code>C</code>点的坐标，那么就可以画出剪头的位置所在。</p>
<p>我们定义一个新的枚举，用于标识象限。</p>
<pre><code class="language-objective-c">/**
 * 剪头距离中心的象限位置

 - GBMaskItemQuadrant1: 第一象限
 - GBMaskItemQuadrant2: 第二象限
 - GBMaskItemQuadrant3: 第三象限
 - GBMaskItemQuadrant4: 第四象限
 */
typedef NS_ENUM(NSUInteger, GBMaskItemQuadrant) {
    GBMaskItemQuadrant1,
    GBMaskItemQuadrant2,
    GBMaskItemQuadrant3,
    GBMaskItemQuadrant4,
};
</code></pre>
<blockquote>
<p>当时可能不是把剪头作为中心点的，所以当时计算可能有点出入。</p>
</blockquote>
<pre><code class="language-objective-c">/**
 * 剪头距离中心点的象限
 */
@property (nonatomic, assign) GBMaskItemQuadrant arrowQuadrant;
</code></pre>
<p>我们怎么定位 <code>B</code>的位置，因为现在我们只知道 <code>A</code>点的位置，我们不可能让使用的人给出 <code>B</code>点的位置，这样以后适配很麻烦。</p>
<p>我们就引入了叫做 <code>偏移量</code>东西，有了 <code>B</code>点距离 <code>A</code>的偏移量，我们自然就可以求出 <code>B</code>的坐标。</p>
<pre><code class="language-objective-c">/**
 * 剪头距离中心圆的偏移量
 */
@property (nonatomic, assign) CGPoint arrowOffset;
</code></pre>
<p>为了求出 <code>C</code>点我们需要知道剪头图片的大小，这个我们都可以通过 UI 给的图片看出来，这个设置也是简单的。</p>
<pre><code class="language-objective-c">/**
 * 剪头的范围大小
 */
@property (nonatomic, assign) CGSize arrowSize;
</code></pre>
<p>有了这么，如果没有图片，我们怎么显示出来。我们新建一个图片的变量。</p>
<pre><code class="language-objective-c">/**
 * 剪头的图片
 */
@property (nonatomic, strong) UIImage *arrowImage;
</code></pre>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-3d97ff27efc02b6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="272AF3ED-89C5-43D0-A965-290F9B2FC0F9"></p>
<p>我们剩下的是放置提示的文本。我们发现放置文本只存在两种情况，也么在剪头图片的上方，要么在剪头图片的下方。</p>
<p>我们新建一个枚举用于标识。</p>
<pre><code class="language-objective-c">/**
 * 箭头提示文本在剪头的方向

 - GBMaskItemArrowTipPosiionTop: 上方
 - GBMaskItemArrowTipPosiionBottom: 下方
 */
typedef NS_ENUM(NSUInteger, GBMaskItemArrowTipPosition) {
    GBMaskItemArrowTipPositionTop,
    GBMaskItemArrowTipPositionBottom,
};
</code></pre>
<pre><code class="language-objective-c">#pragma mark - 配置提示文本位置
@property (nonatomic, assign) GBMaskItemArrowTipPosition tipPosition;
</code></pre>
<p>我们新建一个字符串变量赋值文本内容</p>
<pre><code class="language-objective-c">/**
 * 提示文本的内容
 */
@property (nonatomic, copy) NSString *tipText;
</code></pre>
<p>效果图有的文本居左，有的居右，我们需要让外部设置布局方式</p>
<pre><code class="language-objective-c">/**
 * 文本的对其方式
 */
@property (nonatomic, assign) NSTextAlignment textAlignment;
</code></pre>
<p>提示文本已经确定好了，现在就是个人中心的蒙版</p>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-ddd3532cb01d9578.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C5917E49-FF02-49FF-8AE7-EA7802935FDD"></p>
<p>绘制椭圆我们需要知道这个椭圆外部长方形的大小，我们新加下面的属性。</p>
<pre><code class="language-objective-c">/**
 * 绘制椭圆的大小
 */
@property (nonatomic, assign) CGSize ovalSize;
</code></pre>
<p>我们还需要开放文本和剪头图片控件的试图</p>
<pre><code class="language-objective-c">/**
 * 提示文本
 */
@property (nonatomic, strong, readonly) UILabel *tipLabel;
/**
 * 剪头的图片
 */
@property (nonatomic, strong, readonly) UIImageView *arrowImageView;
</code></pre>
<pre><code class="language-objective-c">- (UILabel *)tipLabel {
    if (!_tipLabel) {
        _tipLabel = [[UILabel alloc] initWithFrame:CGRectZero];
        _tipLabel.textColor = [UIColor whiteColor];
        _tipLabel.font = [UIFont systemFontOfSize:14];
        _tipLabel.numberOfLines = 0;
    }
    return _tipLabel;
}

- (UIImageView *)arrowImageView {
    if (!_arrowImageView) {
        _arrowImageView = [[UIImageView alloc] initWithFrame:CGRectZero];
        _arrowImageView.contentMode = UIViewContentModeScaleAspectFit;
    }
    return _arrowImageView;
}
</code></pre>
<p>我们的数据模型类已经配置完毕，现在我们要开始我们正常奇妙之旅了。</p>
<pre><code class="language-objective-c">- (void)makeMask {
  	// 如果没有配置数据 就可以直接返回 什么都不做
    if (_maskItems.count == 0) {
        return;
    }
  	 // 绘制一个整个大小的画板 用于防止镂空的路径
    UIBezierPath *path = [UIBezierPath bezierPathWithRect:self.bounds];
  	// 便利外部传入的数据源
    [_maskItems enumerateObjectsUsingBlock:^(GBBaseMaskViewItem * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        switch (obj.maskStyle) {
            // 如果是原型 就绘制圆形
            case GBMaskItemStyleCircle: {
                [path appendPath:[self addArcBezierPath:obj isDash:NO]];
            }
                break;
            // 如果是椭圆 就绘制椭圆
            case GBMaskItemStyleOval: {
                [path appendPath:[self addOvalBezierPath:obj isDask:NO]];
            }
                break;
            default:
                break;
        }
      	// 添加剪头图标
        [self addArrowImageInView:obj];
      	// 添加提示文本
        [self addArrowTipLabel:obj];
    }];
  	// 新建一个CAShapeLayer用于绘制我们的路径 做镂空
    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
    shapeLayer.path = path.CGPath;
    self.layer.mask = shapeLayer;
}
</code></pre>
<p>上面的代码就是我们蒙版绘制的核心。</p>
<p>下面是绘制圆形的方法</p>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-c60c3a990932c1c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A864B257-D350-4668-B663-F93715F03459"></p>
<pre><code class="language-objective-c">/*
* 绘制一个圆形
* @param item 配置的数据源
* @param isDash 是否需要绘制虚线圈 也就是上图的所指示位置
*/
- (UIBezierPath *)addArcBezierPath:(GBBaseMaskViewItem *)item isDash:(BOOL)isDash {
  	// 设置绘制的圆比我们设置的大3 因为我们外部是按照图片尺寸设置的 所以需要大于3 实际情况你们可以自己决定
    CGFloat radius = item.radius + 3;
  	// 如果是绘制虚线圈就 让范围大一些
    if (isDash) {
        radius += 4;
    }
    UIBezierPath *bezierPath = [UIBezierPath bezierPathWithArcCenter:item.arcCenter radius:radius startAngle:0 endAngle:2 * M_PI clockwise:NO];
    return bezierPath;
}
</code></pre>
<p>下面是绘制椭圆的方法</p>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-ddd3532cb01d9578.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C5917E49-FF02-49FF-8AE7-EA7802935FDD"></p>
<pre><code class="language-objective-c">/*
* 绘制椭圆形
* @param item 配置的数据
* @param isDash 是否是绘制外围的虚线圈
*/
- (UIBezierPath *)addOvalBezierPath:(GBBaseMaskViewItem *)item isDask:(BOOL)isDash {
  	// 设置偏移量为3
    CGFloat offSet = 3;
  	// 如果是虚线圈就设置5 大一些
    if (isDash) {
        offSet = 5;
    }
    CGRect rect = CGRectMake(item.arcCenter.x - item.ovalSize.width / 2.0 - offSet, item.arcCenter.y - item.ovalSize.height / 2.0 - offSet, item.ovalSize.width + offSet * 2, item.ovalSize.height + offSet * 2);
    UIBezierPath *bezierPath = [[UIBezierPath bezierPathWithOvalInRect:rect] bezierPathByReversingPath];
    return bezierPath;
}
</code></pre>
<p>添加剪头的图片</p>
<pre><code class="language-objective-c">/*
* 添加剪头的图片到试图中
* @param item 配置的数据对象
*/
- (void)addArrowImageInView:(GBBaseMaskViewItem *)item {
  	// 如果没有设置图片就不设置
    if (!item.arrowImage) {
        return;
    }
  	// 如果没有设置大小 也不设置
    if (CGSizeEqualToSize(item.arrowSize, CGSizeZero)) {
        return;
    }
  	// 根据绘制的中心点和偏移量计算出 剪头点的位置坐标
    CGPoint arrowPoint = CGPointMake(item.arcCenter.x + item.arrowOffset.x, item.arcCenter.y + item.arrowOffset.y);
  	// 剪头点坐标对点的坐标值
    CGFloat arrowCenterX, arrowCenterY;
  	// 因为参考点是剪头图片的中心点 所以计算方法如下 因为屏幕的值从上到下 从左到右依次增大的。
    switch (item.arrowQuadrant) {
        // 如果是第一象限 X-W/2 Y+H/2
        case GBMaskItemQuadrant1: {
            arrowCenterX = arrowPoint.x - item.arrowSize.width / 2.0;
            arrowCenterY = arrowPoint.y + item.arrowSize.height / 2.0;
        }
            break;
        // 如果是第二象限 X+W/2 Y+H/2
        case GBMaskItemQuadrant2: {
            arrowCenterX = arrowPoint.x + item.arrowSize.width / 2.0;
            arrowCenterY = arrowPoint.y + item.arrowSize.height / 2.0;
        }
            break;
        //如果是第三象限 X+W/2 Y-H/2
        case GBMaskItemQuadrant3: {
            arrowCenterX = arrowPoint.x + item.arrowSize.width / 2.0;
            arrowCenterY = arrowPoint.y - item.arrowSize.height / 2.0;
        }
            break;
        //如果是第四象限 X-W/2 Y-H/2
        case GBMaskItemQuadrant4: {
            arrowCenterX = arrowPoint.x - item.arrowSize.width / 2.0;
            arrowCenterY = arrowPoint.y - item.arrowSize.height / 2.0;
        }
            break;
        default:
            break;
    }
    item.arrowImageView.image = item.arrowImage;
    item.arrowImageView.frame = CGRectMake(0, 0, item.arrowSize.width, item.arrowSize.height);
    item.arrowImageView.center = CGPointMake(arrowCenterX, arrowCenterY);
    [self addSubview:item.arrowImageView];
}
</code></pre>
<p>添加提示文本</p>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-ba3b7c1bdd8d00e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="B28319B2-BFEC-4333-9F8A-2FA02C2E87A0"></p>
<pre><code class="language-objective-c">/*
* 添加提示文本
* @param item 配置的对象
*/
- (void)addArrowTipLabel:(GBBaseMaskViewItem *)item {
  	// 如果没有设置提示文本就不设置
    if (item.tipText.length == 0) {
        return;
    }
    item.tipLabel.text = item.tipText;
    item.tipLabel.textAlignment = item.textAlignment;
    [self addSubview:item.tipLabel];
  	// 设置提示文本如上图红线圈所示，左侧5 右侧5 和剪头图片的距离为5 下面不设置自适应 怎么可以形成上图的结果呢  我们可以让文本添加\n 换行符即可。
    [item.tipLabel mas_makeConstraints:^(MASConstraintMaker *make) {
        make.leading.mas_offset(10);
        make.trailing.mas_offset(-10);
        switch (item.tipPosition) {
            case GBMaskItemArrowTipPositionTop: {
                make.bottom.equalTo(item.arrowImageView.mas_top).offset(-5);
            }
                break;
            case GBMaskItemArrowTipPositionBottom: {
                make.top.equalTo(item.arrowImageView.mas_bottom).offset(5);
            }
                break;
            default:
                break;
        }
    }];
}
</code></pre>
<p>到此位置我们虚线圈还是没有绘制出来，我们刚才的代码为什么没有出现虚线圈的代码？</p>
<p>那是因为如果设置虚线圈，则是镂空，无法出现设计图的效果。我们需要进行绘制，则是用到了 <code>drawRect</code>方法。</p>
<pre><code class="language-objective-c">- (void)drawRect:(CGRect)rect {
    [super drawRect:rect];
    [_maskItems enumerateObjectsUsingBlock:^(GBBaseMaskViewItem * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        switch (obj.maskStyle) {
            // 如果是圆类型 就绘制圆形虚线圈
            case GBMaskItemStyleCircle: {
                [[self addDashInBezierPath:[self addArcBezierPath:obj isDash:YES]] fill];
            }
                break;
            // 如果是椭圆类型 就绘制椭圆形虚线圈
            case GBMaskItemStyleOval: {
                [[self addDashInBezierPath:[self addOvalBezierPath:obj isDask:YES]] fill];
            }
                break;
            default:
                break;
        }
    }];
}
</code></pre>
<p>添加虚线圈</p>
<pre><code class="language-objective-c">- (UIBezierPath *)addDashInBezierPath:(UIBezierPath *)bezierPath {
    [[UIColor whiteColor] setStroke];
    bezierPath.lineWidth = 2;
    CGFloat dash[] = {3,3};
    [bezierPath setLineDash:dash count:2 phase:0];
    [bezierPath stroke];
    return bezierPath;
}
</code></pre>
<p>别问我这里面值怎么来的，我也是通过 <code>PaintCode</code>这个软件做出来，再设置的。就是通过下面的软件，一个图形，或者是动画可以生成代码软件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-1c2e706c6526585c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="93584A07-C604-45FA-9E3B-AEFDFA2C7655"></p>
<p>此时我们封装蒙版基类已经完成了。</p>
<p>剩下就十分简单了，我们只需要创建一个 <code>GBBaseMaskView</code>的子类，实现 <code>GBBaseMaskViewDataSource</code>协议，配置我们需要的数据。</p>
<p>还有一点忘记说明，我们可以在父类添加下面方法，用于查找试图对应父类试图所在的中心点位置。</p>
<pre><code class="language-objective-c">- (CGPoint)convertCenterView:(UIView *)view {
    CGRect rect = [view convertRect:view.bounds toView:self];
    return CGPointMake(CGRectGetMidX(rect), CGRectGetMidY(rect));
}
</code></pre>
<p>这样我们只需要找到界面绘制按钮或者试图对象即可，这样不用考虑界面兼容，完全是自动计算的。</p>
<p>在结束本篇教程之前，还有一个说明点说明一下。如果通过系统自带的方法创建 <code>UIBarButtonItem</code>是无法找到对象，需要查找子试图，并且在 <code>iOS11</code>上面改了试图层次。</p>
<p><strong>通过标题或者是图片获取导航条按钮的对象</strong></p>
<pre><code>- (UIButton *)gb_barButtonWithTitle:(NSString *)title {
    return [self findBarButtonInView:self verify:^BOOL(UIButton *btn) {
        return [[btn titleForState:UIControlStateNormal] isEqualToString:title];
    }];
}

- (UIButton *)gb_barButtonWithImage:(UIImage *)image {
    return [self findBarButtonInView:self verify:^BOOL(UIButton *btn) {
        return btn.imageView.image.hash == image.hash;
    }];
}

- (UIButton *)findBarButtonInView:(UIView *)view verify:(BOOL(^)(UIButton *btn))verify {
    for (UIButton *btn in [self findAllButtonsInView:view]) {
        if (verify(btn)) {
            return btn;
        }
    }
    return nil;
}

- (NSArray&lt;UIButton *&gt; *)findAllButtonsInView:(UIView *)view {
    NSMutableArray&lt;UIButton *&gt; *buttons = [NSMutableArray array];
    [view.subviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        if ([view isKindOfClass:[UIButton class]]) {
            [buttons addObject:(UIButton *)view];
        }
        [buttons addObjectsFromArray:[self findAllButtonsInView:obj]];
    }];
    return buttons;
}
</code></pre>
<p>还有就是 <code>UITabBar</code>我们可以通过下面的方法获取。</p>
<pre><code class="language-objective-c">- (UIImageView *)gb_tabbarItemTitle:(NSString *)title {
    __block UIImageView *imageView;
    [[self findAllBarButtonInView:self] enumerateObjectsUsingBlock:^(UIButton * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        BOOL isNeedButton = NO;
        for (UIView *v in obj.subviews) {
            if ([v isKindOfClass:[UIImageView class]]) {
                imageView = (UIImageView *)v;
            }
            if ([v isKindOfClass:[UILabel class]]) {
                UILabel *label = (UILabel *)v;
                isNeedButton = [label.text isEqualToString:title];
            }
        }
        if (isNeedButton) {
            *stop = YES;
        }
    }];
    return imageView;
}

- (NSArray&lt;UIButton *&gt; *)findAllBarButtonInView:(UIView *)view {
    NSMutableArray *buttons = [NSMutableArray array];
    [view.subviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        if ([view isKindOfClass:NSClassFromString(@&quot;UITabBarButton&quot;)]) {
            [buttons addObject:view];
        }
        [buttons addObjectsFromArray:[self findAllBarButtonInView:obj]];
    }];
    return buttons;
}
</code></pre>
<p>这样我们这个需求就基本完成了，剩下就是配置数据源就可以出现。如果以后再有类似界面，我们只用新建一个子类，配置数据源即可。</p>
<p>看完了本篇文章，是不是觉得做这样镂空的新手指引特别简单呢。</p>
<p><strong>扩展阅读</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-6fc6b7af39a0ca66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A8CE916E-AE02-46C1-85C1-C44EDCE8ABEC"></p>
<p>此处的展示还有一点小坑，那就是这是一个表格。刚开始这个表格并没有显示这个 <code>cell</code>。当滑动出现才展示出来。</p>
<p>这样就要这样做</p>
<ul>
<li>滑动停止或者拖动停止</li>
<li>滑动 <code>Settings</code>的 <code>Cell</code>的底部一定要出可视范围大于20</li>
<li>用变量标记 出现之后来回滚动不会再次出现</li>
</ul>
<p>这样才能不会有来回快速滚动 或者 只露出一点 就显示出来的 BUG</p>
]]></content>
    </entry>
</feed>