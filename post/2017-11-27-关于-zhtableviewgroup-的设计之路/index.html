<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>关于 ZHTableViewGroup 的设计之路 | 君赏博客</title>
<meta name="description" content="2012年从事iOS开发，资深iOS开发菜鸟，目前在环球易购占坑。喜欢研究偏门技术，喜欢自动化编程，喜欢研究小软件提高编程效率">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://joserccblog.github.io/favicon.ico?v=1555670817008">
<link rel="stylesheet" href="https://joserccblog.github.io/styles/main.css">


  

  
    <link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css" />
  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-80371795-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-80371795-5');
</script>


  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://joserccblog.github.io">
        <img src="https://joserccblog.github.io/images/avatar.png?v=1555670817008" class="site-logo">
        <h1 class="site-title">君赏博客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
        
          <a href="/post/contact/" class="site-nav">
            联系作者
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/josercc" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
          <a class="social-link" href="https://weibo.com/kuaiqiantong" target="_blank">
            <i class="fab fa-weibo"></i>
          </a>
        
      
        
      
        
      
    </div>
    <div class="site-description">
      2012年从事iOS开发，资深iOS开发菜鸟，目前在环球易购占坑。喜欢研究偏门技术，喜欢自动化编程，喜欢研究小软件提高编程效率
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">关于 ZHTableViewGroup 的设计之路</h2>
            <div class="post-date">2017-11-27</div>
            
              <div class="feature-container" style="background-image: url('http://ipicimage-1251019290.coscd.myqcloud.com/2017-11-27-053551.jpg')">
              </div>
            
            <div class="post-content">
              <p>关于 ZHTableViewGroup 的设计之路</p>
<h3 id="关于zhtableviewgroup思想如何产生">关于ZHTableViewGroup思想如何产生</h3>
<ul>
<li>之前复杂的页面不用表格要对于小屏幕做适配添加滚动 需要可以滚动的试图无非就是 UIScrollView 或者 UIScrollView 的子类</li>
<li>删除页面某些试图或者增加没那么容易</li>
<li>做复杂的表单十分复杂要写一些判断逻辑 十分的复杂</li>
<li>对于表格的元素赋值要精确不认会 crash</li>
<li>等等其他吐槽的原因</li>
</ul>
<h3 id="我对于针对-uitableview-平时经常用到的方法和判断做一些分离-这样岂不是就可以分开逻辑-单独处理">我对于针对 UITableView 平时经常用到的方法和判断做一些分离 这样岂不是就可以分开逻辑 单独处理？</h3>
<p>经过这样的思考，觉得这个办法还是可以的，ZHTableViewGroup应运而生</p>
<h3 id="关于zhtableviewgroup的架构">关于ZHTableViewGroup的架构</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-418c12c581de2e52.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>用户只要负责创建 ZHTableViewDataSource 对象</p>
<p>添加ZHTableViewGroup 分组-&gt;添加ZHTableViewCell 模块</p>
<p>比如下面的界面怎么做呢</p>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-1708ee1282075f4b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这个界面可以分成下面的模块</p>
<p><img src="http://upload-images.jianshu.io/upload_images/545662-c7d3f165d4003490.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>分为三种不同的模块</p>
<p>中间的空格也可以作为一个单独的模块</p>
<p>我们对于 UITableViewDataSource和 UITableViewDelegate 的方法进行分离</p>
<h3 id="返回组的个数">返回组的个数</h3>
<pre><code class="language-swift">public func numberOfSections(in tableView: UITableView) -&gt; Int //返回组的个数
</code></pre>
<p>这个代理方法是设置表格的分组个数 我们用 ZHTableViewGroup 分别代表表格的组</p>
<p>对于用户首先要创建一个ZHTableViewGroup 的数据源对象 ZHTableViewDataSource</p>
<p>因为我们需要知道表格的对象地址，所以我们初始化的时候传入 UITableView 的对象</p>
<pre><code class="language-swift">    /// 初始化ZHTableViewDataSource数据源
    ///
    /// - Parameter tableView: 表格对象
    public init(tableView:UITableView) {
        self.tableView = tableView
        super.init()
    }
</code></pre>
<p>我们创建一个 UITableView 的变量来指向这个内存地址</p>
<pre><code class="language-swift">    /// 托管 UITableView 的对象
    var tableView:UITableView
</code></pre>
<p>之前准备想让用户不用实现 UITableViewDataSource 的代理方法 用运行时或者代理卸载这个库里面 用最简单的代码来完成</p>
<p>最后分析了这样妨碍用户一些自定义的事情 决定还是让用户调用库的方法</p>
<p>我们创建一个数组用于存放 ZHTableViewGroup</p>
<pre><code class="language-swift">    /// ZHTableViewGroup的数组
    public var groups:[ZHTableViewGroup] = []
</code></pre>
<p>因为 UITableView 执行代理的时候 可能用户的 ZHTableViewDataSource 对象还没有创建 所以我们要创建类方法去返回组的个数</p>
<pre><code class="language-swift">    /// 返回分组的个数
    ///
    /// - Parameter dataSource: ZHTableViewDataSource数据源可以为 nil
    /// - Returns: Int分组的个数
    public class func numberOfSections(dataSource:ZHTableViewDataSource?) -&gt; Int {
        guard let dataSource = dataSource else {
            // 当ZHTableViewDataSource用户对象还没有创建的时候返回0
            return 0
        }
        return dataSource.groups.count // 返回 ZHTableViewGroup 数组的个数
    }
</code></pre>
<p>关于groups数组的元素怎么来呢 ? 我们写一个方法来添加元素</p>
<pre><code class="language-swift">    /// 添加分组
    ///
    /// - Parameter completionHandle: 添加分组配置的回调
    public func addGroup(completionHandle:ZHTableViewAddGroupCompletionHandle) {
        let group = ZHTableViewGroup()
        completionHandle(group)
        groups.append(group)
    }
</code></pre>
<p>为什么用回调呢 因为可以让用户可以在外部自定义配置 思想来源于 Masonry</p>
<pre><code class="language-swift">/// 添加分组的回调 group:回调的ZHTableViewGroup
public typealias ZHTableViewAddGroupCompletionHandle = (_ group:ZHTableViewGroup) -&gt; Void
</code></pre>
<h3 id="返回每组-cell-的总数">返回每组 Cell 的总数</h3>
<pre><code class="language-swift">public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int // 返回每组 cell 的总数
</code></pre>
<p>我们创建一个类方法返回 cell的总数</p>
<pre><code class="language-swift">    /// 返回每组 Cell 的总数
    ///
    /// - Parameters:
    ///   - dataSource: ZHTableViewDataSource数据源对象可以为 nil
    ///   - section: 组的索引
    /// - Returns:  cell的总数
    public class func numberOfRowsInSection(dataSource:ZHTableViewDataSource?, section:Int) -&gt; Int {
        guard let group = groupForSection(dataSource: dataSource, section: section) else {
            // 如果获取不到对应的 ZHTableViewGroup 对象就返回0
            return 0
        }
        return group.cellCount
    }
</code></pre>
<p>获取 ZHTableViewGroup 的方法</p>
<pre><code class="language-swift">    ///  获取对应的分组
    ///
    /// - Parameters:
    ///   - dataSource: ZHTableViewDataSource的数据源可以为 nil
    ///   - section: 分组的索引
    /// - Returns: 对应分组对象可能为 nil
    private class func groupForSection(dataSource:ZHTableViewDataSource?, section:Int) -&gt; ZHTableViewGroup? {
        guard let dataSource = dataSource else {
            // 当用户还没有创建ZHTableViewDataSource对象返回 nil
            return nil
        }
        guard dataSource.groups.count &gt; section else {
            // 当取值的索引超出了边界返回 nil
            return nil
        }
        return dataSource.groups[section]
    }
</code></pre>
<p>对于 ZHTableViewGroup的属性cellCount</p>
<pre><code class="language-swift">var cellCount:Int {
        get {
            var count:Int = 0 // 初始化默认 Cell 的数量为0
            for cell in self.cells {
                // 便利 cells 数组的 ZHTableViewCell 的对象
                count += cell.cellNumber // 对ZHTableViewCell的 cell 数量进行累加
            }
            return count
        }
    }
</code></pre>
<h3 id="返回-uitableviewcell-的对象">返回 UITableViewCell 的对象</h3>
<pre><code class="language-swift">public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell // 返回 UITableViewCell 的对象
</code></pre>
<p>我们创建类方法返回 UITableViewCell</p>
<pre><code class="language-swift">    /// 返回对应的UITableViewCell
    ///
    /// - Parameters:
    ///   - dataSource: ZHTableViewDataSource数据源可以为空
    ///   - indexPath: 获取所在的 IndexPath
    /// - Returns: UITableViewCell
    public class func cellForRowAt(dataSource:ZHTableViewDataSource?, indexPath:IndexPath) -&gt; UITableViewCell {
        guard let group = groupForSection(dataSource: dataSource, section: indexPath.section) else {
            // 当分组不存在返回默认的UITableViewCell
            return UITableViewCell()
        }
        guard let cell = group.cellForTableView(tableView: dataSource?.tableView, atIndexPath: indexPath) else {
            // 当获取UITableViewCell 获取不到返回默认的UITableViewCell
            return UITableViewCell()
        }
        return cell
    }
</code></pre>
<p>我们在 ZHTableViewGroup 里面来获取对应的 UITableViewCell</p>
<pre><code class="language-swift">    /// 获取对应的 UITableViewCell
    ///
    /// - Parameters:
    ///   - tableView: 对应的表格 可能为 nil
    ///   - indexPath: 对应的 IndexPath 索引
    /// - Returns: UITableViewCell可能为 nil
    func cellForTableView(tableView:UITableView?, atIndexPath indexPath:IndexPath) -&gt; UITableViewCell? {
        guard let tableView = tableView else {
            // 当表格不存在返回 nil
            return nil
        }
        guard let tableViewCell = tableViewCellForIndexPath(indexPath: indexPath) else {
            // 如果索引获取不到对应的 ZHTableViewCell 就返回 nil
            return nil
        }
        guard let identifier = tableViewCell.identifier else {
            // 如果用户没有设置 Identifier 就返回 nil
            return nil
        }
        let cell = tableView.dequeueReusableCell(withIdentifier: identifier, for: indexPath) // 获取重用的 Cell
        tableViewCell.configCell(cell: cell, indexPath: indexPath) // 配置 cell
        return cell
    }
</code></pre>
<p>获取索引对应的 ZHTableViewCell</p>
<pre><code class="language-swift">    /// 根本索引获取对应的ZHTableViewCell
    ///
    /// - Parameter indexPath:  IndexPath 的索引
    /// - Returns: ZHTableViewCell可能为 nil
    func tableViewCellForIndexPath(indexPath:IndexPath) -&gt; ZHTableViewCell? {
        guard indexPath.row &lt; self.cellCount else {
            // 如果索引超出了总个数就返回 nil
            return nil
        }
        var count:Int = 0 // 设置 cell 总数初始值
        var tableViewCell:ZHTableViewCell? // 保存ZHTableViewCell变量
        for cell in self.cells {
            // 便利 cells 数组里面的ZHTableViewCell
            count += cell.cellNumber // 累加 cell 的数量
            if indexPath.row &lt; count {
                // 当索引在当前ZHTableViewCell范围内 就返回ZHTableViewCell对象
                tableViewCell = cell
                break
            }
        }
        return tableViewCell
    }
</code></pre>
<h2 id="设置-cell-的高度">设置 Cell 的高度</h2>
<pre><code class="language-swift">public func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat // 设置 Cell 的高度
</code></pre>
<pre><code class="language-swift">    /// 获取 cell 的高度
    ///
    /// - Parameters:
    ///   - dataSource: ZHTableViewDataSource数组源
    ///   - indexPath: 索引位置
    ///   - customHeightCompletionHandle: 自定义高度方法回调
    /// - Returns:  cell 的高度
    public class func heightForRowAt(dataSource:ZHTableViewDataSource?, indexPath:IndexPath, customHeightCompletionHandle:ZHTableViewDataSourceCustomHeightCompletionHandle?) -&gt; CGFloat {
        guard let cell = cellForIndexPath(dataSource: dataSource, atIndexPath: indexPath) else {
            // 如果 ZHTableViewCell 不存在就直接返回0
            return 0
        }
        return heightWithCustomHandle(height: cell.height, customCompletionHandle: customHeightCompletionHandle)
    }
</code></pre>
<p>获取高度判断的方法</p>
<pre><code class="language-swift">    ///  返回高度
    ///
    /// - Parameters:
    ///   - height: 固定的高度
    ///   - customCompletionHandle: 自定义高度回调
    /// - Returns: 高度
    private class func heightWithCustomHandle(height:CGFloat, customCompletionHandle:ZHTableViewDataSourceCustomHeightCompletionHandle?) -&gt; CGFloat {
        if height == CGFloat(NSNotFound) {
            // 如果用户没有设置高度 就查看用户是否自定义高度方法
            guard let customCompletionHandle = customCompletionHandle else {
                // 如果用户自定义高度方法不存在 就返回0
                return 0
            }
            return customCompletionHandle() // 返回用户的自定义高度
        } else {
            return height // 返回用户提前设定的固定高度
        }
    }
</code></pre>
<h2 id="点击-cell">点击 Cell</h2>
<pre><code class="language-swift">public func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) //点击 Cell
</code></pre>
<pre><code class="language-swift">    /// 点击 cell
    ///
    /// - Parameters:
    ///   - dataSource: ZHTableViewDataSource数据源
    ///   - indexPath: 索引位置
    public class func didSelectRowAt(dataSource:ZHTableViewDataSource?, indexPath:IndexPath) {
        guard let tableViewCell = cellForIndexPath(dataSource: dataSource, atIndexPath: indexPath) else {
            // 当找不到 ZHTableViewCell 不存在就直接返回
            return
        }
        let cell = cellForRowAt(dataSource: dataSource, indexPath: indexPath) // 获取点击的 cell
        tableViewCell.didSelectRowAt(cell: cell, indexPath: indexPath) // 告诉ZHTableViewCell 点击了 cell
    }
</code></pre>
<p>更对的信息请查看 <a href="https://github.com/josercc/ZHTableViewGroupSwift/blob/master/README.md">ReadMe</a></p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://joserccblog.github.io/tag/ios" class="tag">
                    iOS
                  </a>
                
                  <a href="https://joserccblog.github.io/tag/di-san-fang-ku" class="tag">
                    第三方库
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://joserccblog.github.io/post/2017-11-27-关于首页设计框架和一些细节处理分析">
                  <h3 class="post-title">
                    关于首页设计框架和一些细节处理分析
                  </h3>
                </a>
              </div>
            

            
              

              
                <div id="disqus_thread" data-aos="fade-in"></div>
              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  
  

  
    <script src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>
    <script>

    var options = {
      shortname: 'josercc',
      apikey: 'DBJHHPsqZBT5EUYFyQmorAozkwxTDoySOnd4bmdt9G29YFySUFhFE6SLZrSCHee4',
    }
    if ('') {
      options.api = ''
    }
    var dsqjs = new DisqusJS(options)

    </script>
  




  </body>
</html>
