<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Bug信息上报平台是如何产生的 | 君赏博客</title>
<meta name="description" content="2012年从事iOS开发，资深iOS开发菜鸟，目前在环球易购占坑。喜欢研究偏门技术，喜欢自动化编程，喜欢研究小软件提高编程效率">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://joserccblog.github.io/favicon.ico?v=1567052486882">
<link rel="stylesheet" href="https://joserccblog.github.io/styles/main.css">


  

  
    <link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css" />
  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-80371795-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-80371795-5');
</script>


  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://joserccblog.github.io">
        <img src="https://joserccblog.github.io/images/avatar.png?v=1567052486882" class="site-logo">
        <h1 class="site-title">君赏博客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
        
          <a href="/post/contact/" class="site-nav">
            联系作者
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/josercc" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
          <a class="social-link" href="https://weibo.com/kuaiqiantong" target="_blank">
            <i class="fab fa-weibo"></i>
          </a>
        
      
        
      
        
      
    </div>
    <div class="site-description">
      2012年从事iOS开发，资深iOS开发菜鸟，目前在环球易购占坑。喜欢研究偏门技术，喜欢自动化编程，喜欢研究小软件提高编程效率
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Bug信息上报平台是如何产生的</h2>
            <div class="post-date">2019-04-20</div>
            
              <div class="feature-container" style="background-image: url('https://cdn.wccftech.com/wp-content/uploads/2016/06/chrome-bug-pirate-movies.jpg')">
              </div>
            
            <div class="post-content">
              <p>最近基于第三方崩溃收集平台<code>BugTag</code> 做了一开源项目，功能极其的相似。</p>
<p><a href="https://github.com/globalegrowbugtag">App崩溃信息收集平台</a></p>
<h2 id="目前分为三个端">目前分为三个端:</h2>
<ul>
<li>
<p><code>Web</code>前端</p>
<p>因为对前端一概不知，基于快速搭建框架 <code>LayUI</code>搭建起来的，只能凑合的用，代码实现极其的烂。</p>
</li>
<li>
<p><code>Swift</code> 服务器</p>
<p>服务器是基于 <code>Swift</code> 语言框架 <code>Perfect</code>第三方的服务器框架，搭建起来的。虽然不是很流行，但是对于我不用其他服务器语言来说，真是大大福音。</p>
</li>
<li>
<p><code>iOS SDK</code></p>
<p>是基于 <code>Objective-C</code>语言制作的崩溃上报信息 <code>SDK</code></p>
</li>
</ul>
<p>对于 <code>Web</code>前端和 <code>Swift</code> 的服务器没有什么可以说的，主要说一下对于 <code>iOS SDK</code>封装的一些心得。</p>
<h2 id="ios-sdk包含的功能">iOS SDK包含的功能</h2>
<ul>
<li>崩溃自动上报</li>
<li>主动上报</li>
</ul>
<h3 id="崩溃信息包含">崩溃信息包含</h3>
<ul>
<li>崩溃当前界面的截屏</li>
<li>用户从启动到上报前的操作行为流</li>
<li>用户打印的 <code>Log</code> 日志</li>
<li>用户的请求信息</li>
<li>用户的设备信息</li>
</ul>
<h2 id="崩溃时当前的屏幕截图">崩溃时当前的屏幕截图</h2>
<p>这个功能十分的好做，只要对当前的 UIWindow 进行截屏即可。</p>
<pre><code class="language-objc">- (UIImage *)getCurrentViewImage {
    UIImage *image;
    UIView *view = [UIApplication sharedApplication].keyWindow;
    CGRect screenCaptureRect = view.bounds;
    UIGraphicsBeginImageContextWithOptions(screenCaptureRect.size, NO, 0.0f);
    [view.layer renderInContext:UIGraphicsGetCurrentContext()];
    image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return image;
}
</code></pre>
<h2 id="用户设备信息">用户设备信息</h2>
<p>我们可以引用第三方库作为支持</p>
<pre><code class="language-ruby">pod 'GBDeviceInfo'
</code></pre>
<pre><code class="language-objc">GBDeviceInfo *device = [GBDeviceInfo deviceInfo];
</code></pre>
<ul>
<li>
<p>设备版本</p>
<pre><code class="language-objc">[NSString stringWithFormat:@&quot;%@.%@.%@&quot;,@(device.osVersion.major),@(device.osVersion.minor),@(device.osVersion.patch)]
</code></pre>
</li>
<li>
<p>设备名称</p>
<pre><code class="language-objc">device.modelString
</code></pre>
</li>
<li>
<p>屏幕大小</p>
<pre><code class="language-objc">[NSString stringWithFormat:@&quot;%@x%@&quot;,@([UIScreen mainScreen].currentMode.size.width),@([UIScreen mainScreen].currentMode.size.height)]
</code></pre>
</li>
<li>
<p>可用内存</p>
<pre><code class="language-objc">[NSString stringWithFormat:@&quot;%@G&quot;,@(device.physicalMemory)]
</code></pre>
</li>
<li>
<p>CPU频率</p>
<pre><code class="language-objc">[NSString stringWithFormat:@&quot;%@GHZ&quot;,@(device.cpuInfo.frequency)]
</code></pre>
</li>
<li>
<p>CPU内核数量</p>
<pre><code class="language-objc">[NSString stringWithFormat:@&quot;%@个&quot;,@(device.cpuInfo.numberOfCores)]
</code></pre>
</li>
<li>
<p>CPU二级缓存大小</p>
<pre><code class="language-objc">[NSString stringWithFormat:@&quot;%@KB&quot;,@(device.cpuInfo.l2CacheSize)]
</code></pre>
</li>
<li>
<p>App版本大小</p>
<pre><code class="language-objc">[[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;]
</code></pre>
</li>
<li>
<p>SDK版本大小</p>
<pre><code class="language-objc">[[[NSBundle bundleForClass:NSClassFromString(@&quot;GlobalegrowBugTag&quot;)] infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;]
</code></pre>
</li>
<li>
<p>电池电量信息</p>
<pre><code class="language-objc">[@([UIDevice currentDevice].batteryLevel) stringValue]
</code></pre>
</li>
<li>
<p>设备的 UUID 信息</p>
<pre><code class="language-objc">[UIDevice currentDevice].identifierForVendor.UUIDString
</code></pre>
</li>
</ul>
<h2 id="用户操作流程">用户操作流程</h2>
<p>因为我们上报的用户操作流程 用户日志 用户的请求信息都是基于用户针对于 App 的一次会话来说的。所以我们可以把这些信息储存在一个临时目录，在 App 启动的时候清理。</p>
<p>我们既然需要做自动上报的 SDK，就尽可能的不能让接入方做配置。这里用的是尽可能，因为下面的日志系统还是需要接入方简单的配置一下的。</p>
<p>目前我们需要用户的操作流程并不是很多，主要上报用户切换到那个 Tab或者 Push 或者 Pop 到哪一个界面和用户模态弹出那个界面。</p>
<p>对于切换 Tab，我们可以监听<code>UITabBarController</code>的代理，这里就有一个问题，我这里监听了<code>UITabBarController</code>的代理，那么其他人就没法得到回调。</p>
<p>在这里我们在重写代理之前，保存之前已经赋值过的代理。</p>
<pre><code class="language-objc">- (void)listenTabbarController:(UITabBarController *)tabbarController {
    if (![_tabbarController isEqual:tabbarController]) {
        if (_tabbarController) {
            _tabbarController.delegate = _delegate;
        }
        _tabbarController = tabbarController;
        _delegate = tabbarController.delegate;
        tabbarController.delegate = self;
        [self switchTabbarWithViewController:tabbarController.selectedViewController];
    }
}

- (void)switchTabbarWithViewController:(UIViewController *)viewController {
    NSString *className = ({
        className = NSStringFromClass([viewController class]);
        if ([viewController isKindOfClass:[UINavigationController class]]) {
            UINavigationController *nav = (UINavigationController *)viewController;
            className = NSStringFromClass([nav.topViewController class]);
        }
        className;
    });
    [[NSNotificationCenter defaultCenter] postNotificationName:GlobalegrowListenTabbarControllerDidSelectedNotification
                                                        object:[NSString stringWithFormat:@&quot;tabbar switch %@&quot;,className]];
}

#pragma mark - UITabBarControllerDelegate
- (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController {
    if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(tabBarController:shouldSelectViewController:)]) {
        return [_delegate tabBarController:tabBarController shouldSelectViewController:viewController];
    }
    return YES;
}
- (void)tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController {
    [self switchTabbarWithViewController:viewController];
    if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(tabBarController:didSelectViewController:)]) {
        [_delegate tabBarController:tabBarController didSelectViewController:viewController];
    }
}
- (void)tabBarController:(UITabBarController *)tabBarController willBeginCustomizingViewControllers:(NSArray&lt;__kindof UIViewController *&gt; *)viewControllers {
    if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(tabBarController:willBeginCustomizingViewControllers:)]) {
        [_delegate tabBarController:tabBarController willBeginCustomizingViewControllers:viewControllers];
    }
}
- (void)tabBarController:(UITabBarController *)tabBarController willEndCustomizingViewControllers:(NSArray&lt;__kindof UIViewController *&gt; *)viewControllers changed:(BOOL)changed {
    if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(tabBarController:willEndCustomizingViewControllers:changed:)]) {
        [_delegate tabBarController:tabBarController willEndCustomizingViewControllers:viewControllers changed:changed];
    }
}
- (void)tabBarController:(UITabBarController *)tabBarController didEndCustomizingViewControllers:(NSArray&lt;__kindof UIViewController *&gt; *)viewControllers changed:(BOOL)changed {
    if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(tabBarController:didEndCustomizingViewControllers:changed:)]) {
        [_delegate tabBarController:tabBarController didEndCustomizingViewControllers:viewControllers changed:changed];
    }
}
- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)tabBarController:(UITabBarController *)tabBarController
                               interactionControllerForAnimationController: (id &lt;UIViewControllerAnimatedTransitioning&gt;)animationController {
    if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(tabBarController:interactionControllerForAnimationController:)]) {
        return [_delegate tabBarController:tabBarController interactionControllerForAnimationController:animationController];
    }
    return nil;
}
- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)tabBarController:(UITabBarController *)tabBarController
                     animationControllerForTransitionFromViewController:(UIViewController *)fromVC
                                                       toViewController:(UIViewController *)toVC {
    if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(tabBarController:fromVC:toVC:)]) {
        return [_delegate tabBarController:tabBarController animationControllerForTransitionFromViewController:fromVC toViewController:toVC];
    }
    return nil;
}
</code></pre>
<p>为了尽可能的覆盖用到的代理方法，我们把重用的都重新走一遍。我们在需要的代理回调的地方，通过通知把当前的页面的类传出去。</p>
<p>在我们接受通知之后，写入到我们的操作日志的文件里面。</p>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-04-20-013248.png" alt="image-20190420093247987"></p>
<h2 id="请求信息">请求信息</h2>
<p>这个对于使用 <code>AFNetworking</code>框架的用户就好办的多了，就算不是使用 <code>NSURLSessionTask</code>也是支持的，多一步配置而已。</p>
<p>我们新建一个类实现 <code>AFNetworkActivityLoggerProtocol</code>协议。</p>
<p>我们在下面的两个方法里面处理我们收到的请求信息即可</p>
<pre><code class="language-objc">- (void)URLSessionTaskDidStart:(NSURLSessionTask *)task
- (void)URLSessionTaskDidFinish:(NSURLSessionTask *)task withResponseObject:(id)responseObject inElapsedTime:(NSTimeInterval )elapsedTime withError:(NSError *)error
</code></pre>
<p><img src="http://ipicimage-1251019290.coscd.myqcloud.com/2019-04-20-014124.png" alt="image-20190420094123804"></p>
<h2 id="用户的日志信息">用户的日志信息</h2>
<p>这个自动化手机就有点难办，搜了很多资料，对于拦截 <code>Apple System Log</code>系统会让用户无法再控制台打印 Log，这十分的不方便。目前的做法只能是写一个类似 <code>NSLog</code>的宏来代替 <code>NSLog</code>.</p>
<pre><code class="language-objc">#define GBT_LOG(formatter,...) GBT_LOG_PRINT([NSDate date], [self class], __LINE__,formatter,##__VA_ARGS__)
NSString *GBT_LOG_PRINT(NSDate *date, Class class, NSUInteger line,NSString *formatter,...) {
    va_list args;
    va_start(args, formatter);
    NSString *log = [[NSString alloc] initWithFormat:formatter arguments:args];
    if (log.length &gt; 0) {
        NSString *printLog = [NSString stringWithFormat:@&quot;%@ %@ %@ %@&quot;,date,class,@(line),log];
        GlobalegrowBugTagLoggerModel *logger = [[GlobalegrowBugTagLoggerModel alloc] init];
        logger.log = printLog;
        [[GlobalegrowBugTag shareGlobalegrowBugTag] writeLogInLogFile:logger];
#ifdef DEBUG
        NSLog(@&quot;%@&quot;,log);
#else
        if ([NSProcessInfo processInfo].environment[@&quot;GBT_LOG&quot;]) {
            NSLog(@&quot;%@&quot;,log);
        }
#endif
    }
    va_end(args);
    return log;
}
</code></pre>
<p>我们对于 <code>Release</code> 只要在 <code>Xcode</code> 的运行变量里面开启</p>
<pre><code> #define GBT_LOG(formatter,...) GBT_LOG_PRINT([NSDate date], [self class], __LINE__,formatter,##__VA_ARGS__)
 NSString *GBT_LOG_PRINT(NSDate *date, Class class, NSUInteger line,NSString *formatter,...) {
     va_list args;
     va_start(args, formatter);
     NSString *log = [[NSString alloc] initWithFormat:formatter arguments:args];
     if (log.length &gt; 0) {
         NSString *printLog = [NSString stringWithFormat:@&quot;%@ %@ %@ %@&quot;,date,class,@(line),log];
         GlobalegrowBugTagLoggerModel *logger = [[GlobalegrowBugTagLoggerModel alloc] init];
         logger.log = printLog;
         [[GlobalegrowBugTag shareGlobalegrowBugTag] writeLogInLogFile:logger];
 #ifdef DEBUG
         NSLog(@&quot;%@&quot;,log);
 #else
         if ([NSProcessInfo processInfo].environment[@&quot;GBT_LOG&quot;]) {
             NSLog(@&quot;%@&quot;,log);
         }
 #endif
     }
     va_end(args);
     return log;
 }
</code></pre>
<p>我们对于 <code>Release</code> 只要在 Xcode 的运行变量里面开启<code>GBT_LOG</code>变量，还是允许输入 Log 信息的。这样即使在线上，我们依然可以收集用户的 Log.</p>
<p>只要接入方全部使用我们的 Log宏，对于一些特殊的要求的可以使用我们的返回值再次使用即可。</p>
<h2 id="自动收集崩溃">自动收集崩溃</h2>
<p>之前做原生支付 SDK 的时候，遇到要主动上报崩溃。但是我们拦截了崩溃，别人怎么拦截。或者第三方拦截，我们怎么接受的问题。</p>
<p>这个崩溃流就好比堆栈，后来的先接受。如果接收到不抛出，前面就无法接受到崩溃，则崩溃流中断。我们为了防止第三方没有抛出崩溃信息，我们可以让接入方把代码卸载入口最下面。</p>
<pre><code class="language-objc">static NSUncaughtExceptionHandler *GlobalegrowPreviousHandler;
void GlobalegrowHandleException(NSException *exception) {
    NSString *json = [NSString stringWithFormat:@&quot;reason:\n%@\n\n\callStackSymbols:\n%@&quot;,exception.reason,exception.callStackSymbols];
    [[NSNotificationCenter defaultCenter] postNotificationName:GlobalegrowExceptionNotificationName object:json];
    GlobalegrowPreviousHandler(exception);
}

void GlobalegrowRegisterSignalHandler(void) {
    GlobalegrowPreviousHandler = NSGetUncaughtExceptionHandler();
    NSSetUncaughtExceptionHandler(&amp;GlobalegrowHandleException);
}
</code></pre>
<p>我们拿到崩溃信息之后，我们再次的抛出即可。</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://joserccblog.github.io/tag/JoQVIh6gn" class="tag">
                    Bug
                  </a>
                
                  <a href="https://joserccblog.github.io/tag/ASApRah3U" class="tag">
                    开源
                  </a>
                
                  <a href="https://joserccblog.github.io/tag/fFuoYLr4i" class="tag">
                    崩溃信息平台
                  </a>
                
                  <a href="https://joserccblog.github.io/tag/framework" class="tag">
                    Framework
                  </a>
                
              </div>
            
            

            
              

              
                <div id="disqus_thread" data-aos="fade-in"></div>
              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  
  

  
    <script src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>
    <script>

    var options = {
      shortname: 'josercc',
      apikey: 'DBJHHPsqZBT5EUYFyQmorAozkwxTDoySOnd4bmdt9G29YFySUFhFE6SLZrSCHee4',
    }
    if ('') {
      options.api = ''
    }
    var dsqjs = new DisqusJS(options)

    </script>
  




  </body>
</html>
